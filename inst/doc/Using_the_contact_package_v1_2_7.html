<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Trevor S. Farthing" />

<meta name="date" content="2021-04-29" />

<title>Using the contact package</title>

<script src="data:application/javascript;base64,Ly8gUGFuZG9jIDIuOSBhZGRzIGF0dHJpYnV0ZXMgb24gYm90aCBoZWFkZXIgYW5kIGRpdi4gV2UgcmVtb3ZlIHRoZSBmb3JtZXIgKHRvCi8vIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3Igb2YgUGFuZG9jIDwgMi44KS4KZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKGUpIHsKICB2YXIgaHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCJkaXYuc2VjdGlvbltjbGFzcyo9J2xldmVsJ10gPiA6Zmlyc3QtY2hpbGQiKTsKICB2YXIgaSwgaCwgYTsKICBmb3IgKGkgPSAwOyBpIDwgaHMubGVuZ3RoOyBpKyspIHsKICAgIGggPSBoc1tpXTsKICAgIGlmICghL15oWzEtNl0kL2kudGVzdChoLnRhZ05hbWUpKSBjb250aW51ZTsgIC8vIGl0IHNob3VsZCBiZSBhIGhlYWRlciBoMS1oNgogICAgYSA9IGguYXR0cmlidXRlczsKICAgIHdoaWxlIChhLmxlbmd0aCA+IDApIGgucmVtb3ZlQXR0cmlidXRlKGFbMF0ubmFtZSk7CiAgfQp9KTsK"></script>
<link href="data:text/css,%0Aa%2Eanchor%2Dsection%20%7Bmargin%2Dleft%3A%2010px%3B%20visibility%3A%20hidden%3B%20color%3A%20inherit%3B%7D%0Aa%2Eanchor%2Dsection%3A%3Abefore%20%7Bcontent%3A%20%27%23%27%3B%7D%0A%2EhasAnchor%3Ahover%20a%2Eanchor%2Dsection%20%7Bvisibility%3A%20visible%3B%7D%0A" rel="stylesheet" />
<script src="data:application/javascript;base64,Ly8gQW5jaG9yIHNlY3Rpb25zIHYxLjAgd3JpdHRlbiBieSBBdHN1c2hpIFlhc3Vtb3RvIG9uIE9jdCAzcmQsIDIwMjAuCmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHsKICAvLyBEbyBub3RoaW5nIGlmIEFuY2hvckpTIGlzIHVzZWQKICBpZiAodHlwZW9mIHdpbmRvdy5hbmNob3JzID09PSAnb2JqZWN0JyAmJiBhbmNob3JzLmhhc093blByb3BlcnR5KCdoYXNBbmNob3JKU0xpbmsnKSkgewogICAgcmV0dXJuOwogIH0KCiAgY29uc3QgaCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2gxLCBoMiwgaDMsIGg0LCBoNSwgaDYnKTsKCiAgLy8gRG8gbm90aGluZyBpZiBzZWN0aW9ucyBhcmUgYWxyZWFkeSBhbmNob3JlZAogIGlmIChBcnJheS5mcm9tKGgpLnNvbWUoeCA9PiB4LmNsYXNzTGlzdC5jb250YWlucygnaGFzQW5jaG9yJykpKSB7CiAgICByZXR1cm4gbnVsbDsKICB9CgogIC8vIFVzZSBzZWN0aW9uIGlkIHdoZW4gcGFuZG9jIHJ1bnMgd2l0aCAtLXNlY3Rpb24tZGl2cwogIGNvbnN0IHNlY3Rpb25faWQgPSBmdW5jdGlvbih4KSB7CiAgICByZXR1cm4gKCh4LmNsYXNzTGlzdC5jb250YWlucygnc2VjdGlvbicpIHx8ICh4LnRhZ05hbWUgPT09ICdTRUNUSU9OJykpCiAgICAgICAgICAgID8geC5pZCA6ICcnKTsKICB9OwoKICAvLyBBZGQgYW5jaG9ycwogIGguZm9yRWFjaChmdW5jdGlvbih4KSB7CiAgICBjb25zdCBpZCA9IHguaWQgfHwgc2VjdGlvbl9pZCh4LnBhcmVudEVsZW1lbnQpOwogICAgaWYgKGlkID09PSAnJykgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIGxldCBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7CiAgICBhbmNob3IuaHJlZiA9ICcjJyArIGlkOwogICAgYW5jaG9yLmNsYXNzTGlzdCA9IFsnYW5jaG9yLXNlY3Rpb24nXTsKICAgIHguY2xhc3NMaXN0LmFkZCgnaGFzQW5jaG9yJyk7CiAgICB4LmFwcGVuZENoaWxkKGFuY2hvcik7CiAgfSk7Cn0pOwo="></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<link rel="stylesheet" href="data:text/css,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" type="text/css" />




</head>

<body>




<h1 class="title toc-ignore">Using the contact package</h1>
<h4 class="author">Trevor S. Farthing</h4>
<h4 class="date">2021-04-29</h4>



<div id="package-description-and-vignette-purpose" class="section level2">
<h2>Package description and vignette purpose</h2>
<p>The contact package is intended to allow for easy processing of spatiotemporal data into contact and social networks, and facilitate network analysis by randomizing individuals’ movement paths and/or related categorical variables. To use this package, users need only have a dataset containing spatial data (i.e., latitude/longitude, or planar xy coordinates), individual IDs relating spatial data to specific individuals, and date/time information relating spatial locations to temporal locations. The functionality of this package ranges from data “cleaning” via multiple filtration functions, to spatial and temporal data interpolation, and network creation and summarization. Functions within this package are not limited to describing interpersonal contacts. Package functions can also identify and quantify “contacts” between individuals and fixed areas (e.g., home ranges, waterbodies, buildings, etc.). As such, this package is an incredibly useful resource for facilitating epidemiological, ecological, ethological and sociological research.</p>
<p>Here we demonstrate how to use contact functions to:</p>
<div id="create-a-point-location-based-environmental-contact-network" class="section level4">
<h4>1.) Create a point-location-based environmental-contact network</h4>
</div>
<div id="create-polygon-intersection-based-contact-networks-using-point-location-data" class="section level4">
<h4>2.) Create polygon-intersection-based contact networks using point-location data</h4>
</div>
<div id="test-networks-against-null-models" class="section level4">
<h4>3.) Test networks against NULL models</h4>
<p>Please note that a manuscript detailing novel methodologies we’ve developed for accounting for space and real-time location-system accuracy when creating contact networks from point-location data was recently published in <em>Ecology and Evolution</em>. This same manuscript introduces the <em>contact</em> package to the scientific community. Our methods are described briefly in this vignette, but are presented in much greater detail in our manuscript, which is available at <a href="https://doi.org/10.1002/ece3.6225" class="uri">https://doi.org/10.1002/ece3.6225</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#load the contact package</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(contact)</span></code></pre></div>
</div>
<div id="section-1.-creating-a-point-location-based-environmental-contact-network" class="section level3">
<h3>Section 1.) Creating a point-location-based environmental contact network</h3>
<p>Here, we show how to create a contact network detailing the number of contacts each tracked individual has with fixed area/points. In this case, our network will represent contacts between calves in a single feedlot pen with their water trough (for which we know the coordinates). The data set we use, calves, is comprised of point-locations collected using a radio-telemetry-based real-time location system (RTLS) (Smartbow GmbH, Weibern, Austria) to monitor the locations of n = 10 steers in a single 30m X 35m feedlot pen located at the Kansas State University Beef Cattle Research Center in Manhattan, KS. Manufacturer-reported RTLS spatial resolution and accuracy was 0.5m and 90%, respectively (i.e., 90% of location fixes are within 0.5m of animals’ true locations). Tracked steers were approximately 1.5 years old, with estimated 1.5-m nose-to-tail lengths and 0.5-m shoulder widths, and radio-frequency-identication (RFID) tracking devices were located on animals’ left ears. Data in this set were collected continuously between 00:00:00 and 02:00:00 UTC on 06/01/2018 at a 5-10s temporal resolution (i.e., positional fixes for each individual were obtained every 5-10 seconds).</p>
<p>Using the calves data set, we identify the number of “contacts” each individual in had with the water trough in their pen. We define “contact” as occuring when point-locations were within a pre-determined spatial-threshold distance (SpTh) of water-trough edges. In this case, we set our initial SpTh as 0.333 m (i.e., the approximate distace from RFID tags to calves’ noses), then re-define this SpTh to account for RTLS accuracy using the findDistThresh function below.</p>
<p>The steps for environmental-contact network creation are described below.</p>
<p><strong>A.) Ensure all required columns exist in the calves data set (i.e., xy coordinates, unique individual IDs, dateTime).</strong></p>
<p><strong>B.) Calculate distances between the water-trough polygon and calves at each time step.</strong></p>
<p><strong>C.) Identify what SpTh value will allow us to capture 99% of contacts, defined as instances when point-locations were within 0.333 m of the water trough, given the RTLS accuracy.</strong></p>
<p><strong>D.) Identify time points when calves were within the re-adjusted SpTh distance from water trough.</strong></p>
<p><strong>E.) Visualize the contact network with edgeweights weighted according to number of observed contacts.</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;calves&quot;</span>) <span class="co">#load the calves data set</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>calves<span class="ot">&lt;-</span><span class="fu">droplevels</span>(calves[<span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>,]) <span class="co">#reduce the size to reduce processing time for this vignette.</span></span></code></pre></div>
<p><strong>A.) Ensure all required columns exist in the calves data set (i.e., xy coordinates, unique individual IDs, dateTime)</strong></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(calves)<span class="co">#The calves data set does not have a singular dateTime column. Rather, it has &quot;date&quot; and &quot;time&quot; columns. We must append a dateTime column to the data frame.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   calftag     x     y     time       date</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1     101 63.38 47.43 00:00:14 05-02-2016</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2     101 63.48 46.59 00:00:22 05-02-2016</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3     101 62.90 47.07 00:00:26 05-02-2016</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 4     101 63.27 47.26 00:00:34 05-02-2016</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5     101 63.04 46.62 00:00:38 05-02-2016</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 6     101 63.53 47.24 00:00:42 05-02-2016</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calves.dateTime<span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">datetime.append</span>(<span class="at">x =</span> calves, <span class="at">date =</span> calves<span class="sc">$</span>date, <span class="at">time=</span> calves<span class="sc">$</span>time, <span class="at">dateTime =</span> <span class="cn">NULL</span>, <span class="at">dateFormat =</span> <span class="st">&quot;mdy&quot;</span>, <span class="at">dateFake =</span> <span class="cn">FALSE</span>, <span class="at">startYear =</span> <span class="cn">NULL</span>, <span class="at">tz.in =</span> <span class="st">&quot;UTC&quot;</span>, <span class="at">tz.out =</span> <span class="cn">NULL</span>, <span class="at">month =</span> <span class="cn">FALSE</span>, <span class="at">day =</span> <span class="cn">FALSE</span>, <span class="at">year =</span> <span class="cn">FALSE</span>, <span class="at">hour =</span> <span class="cn">FALSE</span>, <span class="at">minute =</span> <span class="cn">FALSE</span>, <span class="at">second =</span> <span class="cn">FALSE</span>, <span class="at">daySecond =</span> <span class="cn">FALSE</span>, <span class="at">totalSecond =</span> <span class="cn">FALSE</span>))</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   0.175   0.007   0.183</span></span></code></pre></div>
<p><strong>B.) Calculate distances between the water-trough polygon and calves at each time step.</strong></p>
<p>First, we must define the location of the water trough. To do this, we read in point-location data for the water-trough vertices.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>water<span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="fl">61.43315</span>, <span class="fl">61.89377</span>, <span class="fl">62.37518</span>, <span class="fl">61.82622</span>), <span class="at">y =</span> <span class="fu">c</span>(<span class="fl">62.44815</span>, <span class="fl">62.73341</span>, <span class="fl">61.93864</span>, <span class="fl">61.67411</span>)) <span class="co">#This is a data frame containing the x and y coordinates of the four trough vertices.</span></span></code></pre></div>
<p>As noted in the dist2Area_df help documention, polygon-vertex coordinates must be arranged in a particular way. Here we arrange them accordingly.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>water_poly<span class="ot">&lt;-</span><span class="fu">data.frame</span>(<span class="fu">matrix</span>(<span class="at">ncol =</span> <span class="dv">8</span>, <span class="at">nrow =</span> <span class="dv">1</span>)) <span class="co">#(ncol = number of vertices)*2</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>colnum <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(h <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(water)){</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  water_poly[<span class="dv">1</span>,colnum <span class="sc">+</span> h] <span class="ot">&lt;-</span> water<span class="sc">$</span>x[h] <span class="co">#pull the x location for each vertex</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  water_poly[<span class="dv">1</span>, (colnum <span class="sc">+</span> <span class="dv">1</span> <span class="sc">+</span> h)] <span class="ot">&lt;-</span> water<span class="sc">$</span>y[h] <span class="co">#pull the y location for each vertex</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  colnum <span class="ot">&lt;-</span> colnum <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Calculate distances between calves and the water polygon at every timestep.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(water_distance<span class="ot">&lt;-</span>contact<span class="sc">::</span><span class="fu">dist2Area_df</span>(<span class="at">x =</span> calves.dateTime, <span class="at">y =</span> water_poly, <span class="at">x.id =</span> <span class="st">&quot;calftag&quot;</span>, <span class="at">y.id =</span> <span class="st">&quot;water&quot;</span>, <span class="at">dateTime =</span> <span class="st">&quot;dateTime&quot;</span>, <span class="at">point.x =</span> calves.dateTime<span class="sc">$</span>x, <span class="at">point.y =</span> calves.dateTime<span class="sc">$</span>y, <span class="at">poly.xy =</span> <span class="cn">NULL</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">dataType =</span> <span class="st">&quot;Point&quot;</span>, <span class="at">lonlat =</span> <span class="cn">FALSE</span>, <span class="at">numVertices =</span> <span class="cn">NULL</span>)) <span class="co">#note that the poly.xy and numVertices arguments refer to vertices of polygons in x, not y. Because dataType is &quot;Point,&quot; not &quot;Polygon,&quot; these arguments are irrelevant here.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   5.461   0.065   5.537</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(water_distance)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;              dateTime totalIndividuals individualsAtTimestep  id dist.to.water</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1 2016-05-02 00:00:14                3                     1 101      14.32860</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2 2016-05-02 00:00:22                3                     1 101      15.17450</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3 2016-05-02 00:00:26                3                     1 101      14.64353</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 4 2016-05-02 00:00:34                3                     1 101      14.48624</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5 2016-05-02 00:00:38                3                     1 101      15.10296</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 6 2016-05-02 00:00:42                3                     1 101      14.53432</span></span></code></pre></div>
<p><strong>C.) Identify what SpTh value will allow us to capture 99% of contacts, defined as instances when point-locations were within 0.333 m of the water trough, given the RTLS accuracy.</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>SpThValues<span class="ot">&lt;-</span>contact<span class="sc">::</span><span class="fu">findDistThresh</span>(<span class="at">n =</span> <span class="dv">100000</span>, <span class="at">acc.Dist1 =</span> <span class="fl">0.5</span>, <span class="at">acc.Dist2 =</span> <span class="cn">NULL</span>, <span class="at">pWithin1 =</span> <span class="dv">90</span>, <span class="at">pWithin2 =</span> <span class="cn">NULL</span>, <span class="at">spTh =</span> <span class="fl">0.5</span>) <span class="co">#spTh represents the initially-defined spatial threshold for contact. Note that we&#39;ve chosen to use 100,000 in-contact point-location pairs here.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>SpThValues <span class="co">#it looks like an adjusted SpTh value of approximately 1.74 m will likely capture 99 to 100% of contacts, defined as instances when point-locations were within 0.333 m of the water trough, given the RTLS accuracy. #Note that because these confidence intervals are obtained from distributions generated from random samples, every time this function is run, results will be slightly different. </span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $distribution.summary</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;        mean          sd         min         max         TPR </span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 0.707066931 0.345858463 0.004903568 2.624098306 0.303350000 </span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $CI_upper</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    50%-CI    55%-CI    60%-CI    65%-CI    70%-CI    75%-CI    80%-CI    85%-CI </span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 0.7078046 0.7078931 0.7079874 0.7080891 0.7082005 0.7083251 0.7084686 0.7086413 </span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    90%-CI    95%-CI    99%-CI </span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 0.7088659 0.7092105 0.7098841 </span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $CI_lwr</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    50%-CI    55%-CI    60%-CI    65%-CI    70%-CI    75%-CI    80%-CI    85%-CI </span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 0.7063292 0.7062407 0.7061464 0.7060448 0.7059334 0.7058088 0.7056653 0.7054925 </span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    90%-CI    95%-CI    99%-CI </span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 0.7052680 0.7049233 0.7042497 </span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $spTh.adjustments</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  spTh_84%Capture  spTh_98%Capture spTh_100%Capture </span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;         1.052925         1.398784         1.744642 </span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $contact.frequency</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  freq_84%Capture  freq_98%Capture freq_100%Capture </span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;          0.83535          0.96699          0.99619</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>CI_99<span class="ot">&lt;-</span><span class="fu">unname</span>(SpThValues[[<span class="st">&quot;spTh.adjustments&quot;</span>]][<span class="dv">3</span>]) <span class="co">#we will use this SpTh value moving forward.</span></span></code></pre></div>
<p><strong>D.) Identify time points when calves were within the re-adjusted SpTh distance from water trough.</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(water_contacts <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">contactDur.area</span>(water_distance, <span class="at">dist.threshold=</span>CI_99,<span class="at">sec.threshold=</span><span class="dv">1</span>, <span class="at">blocking =</span> <span class="cn">FALSE</span>, <span class="at">equidistant.time =</span> <span class="cn">FALSE</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">reportParameters =</span> <span class="cn">TRUE</span>)) <span class="co">#Note that because we are not interested in making a time-aggregated network with &gt; 1 temporal levels, we set blocking = FALSE to reduce processing time.</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   0.223   0.040   0.263</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(water_contacts)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   indiv.id area.id contact.id contactDuration    contactStartTime</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1      101   water  101-water               1 2016-05-02 00:47:31</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2      101   water  101-water               1 2016-05-02 00:47:35</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3      101   water  101-water               1 2016-05-02 00:47:39</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 4      101   water  101-water               1 2016-05-02 00:47:43</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5      101   water  101-water               1 2016-05-02 00:47:47</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 6      101   water  101-water               1 2016-05-02 00:47:55</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;        contactEndTime distThreshold secThreshold equidistant.time</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1 2016-05-02 00:47:31      1.744642            1            FALSE</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2 2016-05-02 00:47:35      1.744642            1            FALSE</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 3 2016-05-02 00:47:39      1.744642            1            FALSE</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 4 2016-05-02 00:47:43      1.744642            1            FALSE</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 5 2016-05-02 00:47:47      1.744642            1            FALSE</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 6 2016-05-02 00:47:55      1.744642            1            FALSE</span></span></code></pre></div>
<p><strong>E.) Visualize the contact network with edgeweights weighted according to number of observed contacts.</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(water_edges<span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">ntwrkEdges</span>(<span class="at">x =</span> water_contacts, <span class="at">importBlocks =</span> <span class="cn">FALSE</span>, <span class="at">removeDuplicates =</span> <span class="cn">TRUE</span>)) <span class="co">#get specific weighted edges</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    user  system elapsed </span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   0.016   0.003   0.020</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(water_edges)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;   from    to durations</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 1  101 water        18</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2  102 water        49</span></span></code></pre></div>
<p>Now we can vizualize the network using igraph functions.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>water.network <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">simplify</span>(igraph<span class="sc">::</span><span class="fu">graph_from_data_frame</span>(<span class="at">d=</span>water_edges, <span class="at">directed=</span>F, <span class="at">vertices =</span>  <span class="fu">c</span>(<span class="fu">seq</span>(<span class="dv">101</span>,<span class="dv">110</span>), <span class="st">&quot;water&quot;</span>)),<span class="at">remove.multiple =</span> T, <span class="at">remove.loops =</span> T) <span class="co">#Note that we have to specify the nodes here because not all calves were observed in contact with the water trough.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">V</span>(water.network)<span class="sc">$</span>color<span class="ot">&lt;-</span> <span class="st">&quot;orange1&quot;</span> <span class="co">#make calf nodes orange</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">V</span>(water.network)<span class="sc">$</span>color[<span class="fu">length</span>(igraph<span class="sc">::</span><span class="fu">V</span>(water.network))]<span class="ot">&lt;-</span> <span class="st">&quot;steelblue1&quot;</span> <span class="co">#make water node blue</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">V</span>(water.network)<span class="sc">$</span>label<span class="ot">&lt;-</span><span class="cn">NA</span> <span class="co">#no need to label nodes</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">V</span>(water.network)<span class="sc">$</span>size <span class="ot">&lt;-</span><span class="dv">13</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">V</span>(water.network)<span class="sc">$</span>shape<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">&quot;circle&quot;</span>, (<span class="fu">length</span>(igraph<span class="sc">::</span><span class="fu">V</span>(water.network)) <span class="sc">-</span> <span class="dv">1</span>)), <span class="st">&quot;square&quot;</span>) <span class="co">#make the calf nodes circular and the water node square</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">E</span>(water.network)<span class="sc">$</span>width <span class="ot">&lt;-</span> water_edges<span class="sc">$</span>duration<span class="sc">/</span><span class="dv">10</span> <span class="co">#edge width is proportional to contact frequency</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">E</span>(water.network)<span class="sc">$</span>color <span class="ot">&lt;-</span> <span class="st">&quot;black&quot;</span> <span class="co">#make edges black</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>watercoords1<span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">layout_as_star</span>(water.network, <span class="at">center =</span> igraph<span class="sc">::</span><span class="fu">V</span>(water.network)[<span class="fu">length</span>(igraph<span class="sc">::</span><span class="fu">V</span>(water.network))]) <span class="co">#set the center of the star layout as the water polygon</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">plot.igraph</span>(water.network, <span class="at">layout =</span> watercoords1)</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAqAAAAGACAYAAAByeNBuAAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAAqCgAwAEAAAAAQAAAYAAAAAAi22skQAAL/xJREFUeAHt3QmclXW9P/DvDAMMO8gqoCKmgl53s8RAhDQ3BHfNjeuemS1qec30atq1/z/rZpZm5po7plmGCfkXwR1RCxVJwcwNlGVYZGC2/xy6di0OM+N45uE5z3mf16sX47P8ft/f+/s0fDjLc8oaGh/hQYAAAQIECBAgQCAhgfKE5jENAQIECBAgQIAAgbUCAqgLgQABAgQIECBAIFEBATRRbpMRIECAAAECBAgIoK4BAgQIECBAgACBRAUE0ES5TUaAAAECBAgQICCAugYIECBAgAABAgQSFRBAE+U2GQECBAgQIECAgADqGiBAgAABAgQIEEhUQABNlNtkBAgQIECAAAECAqhrgAABAgQIECBAIFEBATRRbpMRIECAAAECBAgIoK4BAgQIECBAgACBRAUE0ES5TUaAAAECBAgQICCAugYIECBAgAABAgQSFRBAE+U2GQECBAgQIECAgADqGiBAgAABAgQIEEhUQABNlNtkBAgQIECAAAECAqhrgAABAgQIECBAIFEBATRRbpMRIECAAAECBAgIoK4BAgQIECBAgACBRAUE0ES5TUaAAAECBAgQICCAugYIECBAgAABAgQSFRBAE+U2GQECBAgQIECAgADqGiBAgAABAgQIEEhUQABNlNtkBAgQIECAAAECAqhrgAABAgQIECBAIFEBATRRbpMRIECAAAECBAgIoK4BAgQIECBAgACBRAUE0ES5TUaAAAECBAgQICCAugYIECBAgAABAgQSFRBAE+U2GQECBAgQIECAgADqGiBAgAABAgQIEEhUQABNlNtkBAgQIECAAAECAqhrgAABAgQIECBAIFEBATRRbpMRIECAAAECBAgIoK4BAgQIECBAgACBRAUE0ES5TUaAAAECBAgQICCAugYIECBAgAABAgQSFRBAE+U2GQECBAgQIECAgADqGiBAgAABAgQIEEhUQABNlNtkBAgQIECAAAECAqhrgAABAgQIECBAIFEBATRRbpMRIECAAAECBAgIoK4BAgQIECBAgACBRAUE0ES5TUaAAAECBAgQICCAugYIECBAgAABAgQSFRBAE+U2GQECBAgQIECAgADqGiBAgAABAgQIEEhUQABNlNtkBAgQIECAAAECAqhrgAABAgQIECBAIFEBATRRbpMRIECAAAECBAgIoK4BAgQIECBAgACBRAUE0ES5TUaAAAECBAgQICCAugYIECBAgAABAgQSFRBAE+U2GQECBAgQIECAgADqGiBAgAABAgQIEEhUQABNlNtkBAgQIECAAAECAqhrgAABAgQIECBAIFEBATRRbpMRIECAAAECBAgIoK4BAgQIECBAgACBRAUE0ES5TUaAAAECBAgQICCAugYIECBAgAABAgQSFRBAE+U2GQECBAgQIECAgADqGiBAgAABAgQIEEhUQABNlNtkBAgQIECAAAECAqhrgAABAgQIECBAIFEBATRRbpMRIECAAAECBAgIoK4BAgQIECBAgACBRAUE0ES5TUaAAAECBAgQICCAugYIECBAgAABAgQSFRBAE+U2GQECBAgQIECAgADqGiBAgAABAgQIEEhUQABNlNtkBAgQIECAAAECAqhrgAABAgQIECBAIFEBATRRbpMRIECAAAECBAgIoK4BAgQIECBAgACBRAUE0ES5TUaAAAECBAgQICCAugYIECBAgAABAgQSFRBAE+U2GQECBAgQIECAgADqGiBAgAABAgQIEEhUQABNlNtkBAgQIECAAAECAqhrgAABAgQIECBAIFEBATRRbpMRIECAAAECBAgIoK4BAgQIECBAgACBRAUE0ES5TUaAQDEIVFdXx7vvvhs1NTXFUO7HrnHlypWxdOnSaGho+NjnOoEAAQKFEBBAC6FoDAIEil4gFzavvvpnsfN2W0bPHt1ix223iB7du8Q+Y/aIKVOmFP363nnnnfj6V78cg/pvFH026hmbbzog+vTqFidNPCZeffXVol+fBRAgUFwCZY3/AvZP4OLqmWoJECiwQC58jhn12ahc8Wpc8PnqGPmpdmtnqK5piHtfqItjb6yJiy/8dlx48aUFnjmZ4V5//fUYsdtOcfSONXH6iNrYou/fn3t4p6ohrp5RFpdNXhXPP/987LDDDskUZBYCBEpeQAAt+UsAAIHSFqivr4/+/frEvp9aFTcdV5YXY9GKhuh3XnX84P9+P84+55t5j0nrxjfffDM22WST+N5BFfGtfdrnLfOOmbVxTGPIfvbZZ2PnnXfOe4yNBAgQKKSAAFpITWMRIFB0ArfccktceM4p8dqFTb8j6Y3F9bHLFe3ipVfmRf/+/YtmnUcfPiH6vD85fnzY35/VXV/hv3y8Nm5+7d9i+pOz1neI7QQIECiYQNO/cQs2jYEIECCQToEbfn5l/HBC8+9E2nSj8jhou/K444470rmQPFUtX748fvvA5LhsXPO/6k/cvV3MnTsnXnvttTwj2USAAIHCCjT/W6mw8xmNAAECqRHIvQX+uT+9GKO3bNmvwtFDV8fMJ6alpv7mCvnTn/4UO2zWJbp2zP/Wgo+eX1ZWFntt3TFmzpz50c1+JkCAQJsItOy3bptMbVACBAhsWIFcAF25ak1069iyOnpUlkVV1ZKWHZyCo6qqqqJn5+bD54el9qisX3t7pg//258ECBBoKwEBtK1kjUuAQOoFysvLo1/vHvHGkuZfgs8tZt6iiMGbbZH6dX1Y4ODBg2Pee3Uf/mezf85fUhG5czwIECDQ1gICaFsLG58AgVQLfGHf/eKOWS37VXj37M6x/4ETUr2ejxa3zTbbxIqaivjzW/Uf3Zz35wXLGuKZeati5MiReffbSIAAgUIKtOy3biFnNBYBAgRSJPCNc/8jfvhIWcx6o+mQdvzNNVHdvl/ss88+Kaq+6VIqKirinPMuiBNur4g1tU0/yzvw/Oo45bTTo3v37k0Pai8BAgQKIOA2TAVANAQBAsUtMGnS3XH44UfE5C93iH2G//PtinLvE73kwfq45IE1sWzZsujWrVvRLfaLRxwct999Xyy8vDJ6d/3n94SuXN0QJ93R+CxpVb94ac6rkfswkgcBAgTaWkAAbWth4xMgUBQC06dPj1xQ26Z/XYzZfEVs1Pjhnb8tbRe/frFjdOu7Wdx5z29j0003LYq15CvyvG+eHdf+/Oo4aPuK2K5fdXRozNkvv98xJj1XHwdNOCSu+cUNkXvG1IMAAQJJCAigSSibgwCBohBYtWpVTJ48OR6b8WhULXkvBgwa0viS+xdixIgRmQhnb7/9dtx///3x8uwXoq6uNoZuOTzGjx8fW2xRPB+sKooLSZEECDQrIIA2S+QAAgQIECBAgACBQgr4EFIhNY1FgAABAgQIECDQrIAA2iyRAwgQIECAAAECBAopIIAWUtNYBAgQIECAAAECzQoIoM0SOYAAAQIECBAgQKCQAgJoITWNRYAAAQIECBAg0KyAANoskQMIECBAgAABAgQKKSCAFlLTWAQIECBAgAABAs0KCKDNEjmAAAECBAgQIECgkAICaCE1jUWAAAECBAgQINCsgADaLJEDCBAgQIAAAQIECikggBZS01gECBAgQIAAAQLNCgigzRI5gAABAgQIECBAoJACAmghNY1FgAABAgQIECDQrIAA2iyRAwgQIECAAAECBAopIIAWUtNYBAgQIECAAAECzQoIoM0SOYAAAQIECBAgQKCQAgJoITWNRYAAAQIECBAg0KyAANoskQMIECBAgAABAgQKKSCAFlLTWAQIECBAgAABAs0KCKDNEjmAAAECBAgQIECgkAIVhRzMWAQIEPhQYMmSJXHPPffE009Mi2VLl8bATTeP/fYfF3vttVdUVPjV86GTP5sW+Nvf/haTJk2K2c8/Haurq2OzLYbFQeMnxG677RZlZWVNn2wvAQKpFShraHyktjqFESBQlAI/v+bquOD8b8aYrcpi9ObV0atzxPzFZXHXnzpFh56bxB+nPRFdu3YtyrUpOjmB8887N6695qdx6I7tYueBq6Nzh4i571XErbPaxTY77Ba/eeChaNeuXXIFmYkAgYIJCKAFozQQAQI5gSv/+4r46tfPiZe+0zG27r/uu3yOvqEm7nq2Nt58880YNGgQNAJ5BX70f74b3/jWhbHw8sro3fWfn+msrWuITS5YEwuX18eKFSuiS5cuecewkQCB9AoIoOntjcoIFJ3A9OnTY9SoUfHX71bG4F7/HBo+upgLflsXjyweHo8+PtPL8R+F8fNageuuuy5OOeWUWPmjyqhsv/7r6OgbI3Y77Lw4uzGoehAgUFwCAmhx9Uu1BFItcOC+Y+KQvo/FxM82/bJo7p0/O13RMa684b4YPXp0qtekuGQF6uvrY9uth8QvDloQI4Y2fR2tWtP4TOhFEX9++VXPpifbJrMR+MQC674+9omHNAABAqUoUFtbG488+ljj+/Wa/7WS+/DIwduujof+8GApUllzEwK5Dx1VLVncbPjMDdGpQ1nst12nmDp1ahMj2kWAQBoFmv+bIo1Vq4kAgdQJVFVVRWWHdtGtcv0vmX606CG96uLtv83/6CY/E4i33347hvTt2GKJzbpXx1tvvdXi4x1IgEA6BATQdPRBFQSKXqB79+6x/IM10dIbayxdFdGjV++iX7cFFFagZ8+esXhFbYsHXbq6InLneBAgUFwCAmhx9Uu1BFIr0L59+9h++Kfi0VfrW1Tjw/O7xO57jGrRsQ4qHYEXXngh/rpgeby9tGV3CJw6N2L33XcvHSArJZARAQE0I420DAJpEDjx9LPivx6ubLaUx+fVxcw3GmLcuHHNHuuA0hCoqamJs846K44++uior2+I/3ygptmFXzO9NrptNDB22mmnZo91AAEC6RIQQNPVD9UQKGqBk046OVZUbh6n3L7+Z0FfWVAfI3+4Jq6/+Xb3byzqbheu+DfeeCNGjhwZP/nJT9YOuqYu4raZdXHF1PWH0N/9uS6+fGdN3PCruwpXiJEIEEhMwG2YEqM2EYHSEFizZk303qhXDOhWF1ce0hCjtyyPjo33cnx3WUPc/VxDfG9qu7j8B1fGv594UmmAWGWTApMnT47jjjsuFi1alPe4scM7xMX7Rey6WXm0b1cW89+vj5tnlsdPZ5THb38/xcvvedVsJJB+AV/InP4eqZBAUQl06NAhllYtixtvvCG+e/WP4+Dr5kR54wfjO3eqjL33HhuTp14YO++8c1GtSbGFF8jd7/Oiiy6Kyy67LO8H13K36sq9JN+vb+/48q03xuy5r0e7xgupT6/uceC48fH0s9+JoUOHFr4wIxIgkIiAZ0ATYTYJgdIVyH0qvrq6OiorKyMXKjwILFy4cO17PR9++OG8GLlPtd90001x0EEH/WN/7jrK3Ws292E3DwIEil9AAC3+HloBAQIEikYg93WtRx111Nr7feYrOvfs+KRJk2LzzTfPt9s2AgQyIuBDSBlppGUQIEAg7QI/+MEPYsyYMesNn6eeemo8/vjjwmfaG6k+AgUQ8B7QAiAaggABAgTWL7B06dKYOHFi/OY3v8l7UJcuXeKaa66JY489Nu9+GwkQyJ6AAJq9nloRAQIEUiMwa9asOPzww2PevHl5axo2bFjcc889sc022+TdbyMBAtkU8BJ8NvtqVQQIENjgAtdee22MGDFiveEzd9P5Z555Rvjc4J1SAIHkBQTQ5M3NSIAAgUwLrFy5cu29PU877bRYvXr1OmvN3arrqquuittuuy26du26zn4bCBDIvoCX4LPfYyskQIBAYgJz5syJww47LF588cW8cw4ZMiTuvvvu2HXXXfPut5EAgdIQ8AxoafTZKgkQINDmArfffnt8+tOfXm/4PPDAAyP3nlDhs81bYQICqRcQQFPfIgUSIEAg3QK5r18988wz44tf/GKsWLFinWLbtWsX3/ve9+L++++PXr16rbPfBgIESk/AS/Cl13MrJkCAQMEEXn/99TjiiCPWfpgo36ADBgyIO+64I/bcc898u20jQKBEBTwDWqKNt2wCBAh8UoEHHnggct9clPske77H6NGj47nnnhM+8+HYRqDEBQTQEr8ALJ8AAQIfV6Curi7OP//8GDduXCxZsmSd08vKyuK8886LqVOnRu4ZUA8CBAj8q4CX4P9VxH8TIECAwHoF3n333cjdv/ORRx7Je0zuPZ633HJLHHDAAXn320iAAIGcgADqOiBAgACBFglMmzYtjjrqqMiF0HyP3Cfg77rrrsjdasmDAAECTQl4Cb4pHfsIECBAIBoaGuLyyy+PsWPHrjd8nnHGGTFjxgzh0/VCgECLBDwD2iImBxEgQKA0BXLv8Tz++OPjd7/7XV6A3DcZ5b5yM/eyvAcBAgRaKiCAtlTKcQQIECgxgZkzZ8bhhx8euVst5Xtsu+22MWnSpBg2bFi+3bYRIEBgvQJegl8vjR0ECBAoXYGrr7469thjj/WGz2OPPTaeeuop4bN0LxErJ/CJBDwD+on4nEyAAIFsCeS+yejUU0+N3Ndq5nt07NgxfvzjH8dpp52Wb7dtBAgQaJGAANoiJgcRIEAg+wIvvfRSHHrooTFnzpy8ix06dGjcfffda28+n/cAGwkQINBCAS/BtxDKYQQIEMiywK9+9avYbbfd1hs+x48fH88++6zwmeWLwNoIJCgggCaIbSoCBAikTWD16tXxpS99KY477rhYuXLlOuVVVFTE97///bjvvvuiZ8+e6+y3gQABAq0R8BJ8a9ScQ4AAgQwIzJ8/Pw477LCYNWtW3tUMHDgw7rjjjhg5cmTe/TYSIECgtQKeAW2tnPMIECBQxAL333//2pfT1xc+x4wZE88995zwWcQ9VjqBNAsIoGnujtoIECBQYIHa2tr41re+FRMmTIilS5euM3pZWVl8+9vfjilTpkS/fv3W2W8DAQIECiHgJfhCKBqDAAECRSDwzjvvxJFHHhnTp0/PW23v3r3jlltuif322y/vfhsJECBQKAEBtFCSxiFAgECKBR5++OG1X5e5cOHCvFV+5jOfibvuuis23XTTvPttJECAQCEFvARfSE1jESBAIGUCDQ0Ncdlll8U+++wT6wufX/nKV9Y+Kyp8pqx5yiGQYQHPgGa4uZZGgEBpCyxatGjt7ZUmT56cF6Jbt25x3XXXxRFHHJF3v40ECBBoKwEBtK1kjUuAAIENKJD7nvZcsHzjjTfyVrHddtvFpEmTYquttsq730YCBAi0pYCX4NtS19gECBDYAAI/+clPYtSoUesNnyeccEI8+eSTwucG6I0pCRD4u4BnQF0JBAgQyIjA8uXL4+STT177YaJ8S6qsrIxcOM0d40GAAIENKSCAbkh9cxMgQKBAArNnz45DDz005s6dm3fELbbYYu1L7jvuuGPe/TYSIEAgSQEvwSepbS4CBAi0gcBNN90UudsorS98HnzwwfHss8+G8NkG+IYkQKBVAgJoq9icRIAAgQ0vUF1dHaecckpMnDgxPvjgg3UKqqioiCuuuCJ+/etfR48ePdbZbwMBAgQ2lICX4DeUvHkJECDwCQRee+21OOyww+L555/PO8qgQYPWvhd0xIgReffbSIAAgQ0p4BnQDalvbgIECLRC4N57741ddtllveFz7733jueeey6Ez1bgOoUAgUQEBNBEmE1CgACBTy5QW1sbZ599dhxyyCFRVVW1zoDl5eVx0UUXxYMPPhh9+/ZdZ78NBAgQSIuAl+DT0gl1ECBAoAmBt956K4488sh47LHH8h7Vp0+fuPXWW9d+5WbeA2wkQIBAigQE0BQ1QykECBDIJzBlypQ45phj4r333su3O3bfffe17/ccPHhw3v02EiBAIG0CXoJPW0fUQ4AAgf8RqK+vj0suuST23Xff9YbPr33tazFt2rQQPl02BAgUk4BnQIupW2olQKBkBN5///21z3o+9NBDedfcvXv3uP7669fefD7vATYSIEAgxQKeAU1xc5RGYEMIrFq1Kn7605/G6BG7RP8+3aPvRt1it52Gx2WXfjeWLFmyIUrKzJyLFy+OsrKy6FjZuZn/dYr+AzaOteGzfN3nCXbYYYe1N5bPffORR/MCubcwHH7wAbHJxr2ja+eOseXmA+OM00+OOXPmNH+yIwgQaBOBsobGR5uMbFACBIpOIBeQRo3YNYZ2WRSnfaY6dhxcHu3bRbz8bn1c/USHuPOpFfHOO+/EgAEDim5taSg4F3hG7n1Q7HFp/nt3/muN86ZcHbPvOD8a6tb8Y9eJJ54YV111VXTq1Okf2/yQXyD3Fobjjzk8nn70oThvzOoYu3V5bNS5LN5Y0hB3P18eF/9uVfzmvnvjoPET8g9gKwECbSaw7j+t22wqAxMgkGaB5cuXR+/eveOoXSvi1ontG0ttTJ7/8xj5qXYx8lN1cdDw9jF0883ipZdfiSFDhny4258fQ6Cs8VZJFR07t+iMsvL/7UEucP7sZz9b+61HLTrZQbH/F8ZG1fwn48XzGq/mjzyTPHxAWVy4b8Rxu3aMrRtvaXXb7XfEEUccQYwAgQQFvASfILapCKRZ4Jtnfy32367j/4TP/JXmwukFX4g48/QTw4sn+Y3aYuvWW28dTz75pPD5MXDvv//+eGTaozH9q7nwWZb3zM37lMeT53SIr5xxireX5BWykUDbCQigbWdrZAJFI5B73+ftt98WNx2b/y/qjy7k3LGNf2k/+UTk7kvp0fYCBx54QMyePTu23377tp8sQzNc85MfxA3Htovy9YTPD5e686blsdeWEZMmTfpwkz8JEEhAwEvwCSCbgkDaBXLfJz5sUKfYqEt1s6Xmnk0aO7wyZsyYEUcddVSzxzvgkwksWLAgLr300k82SImdnXt2fsZjT8YtF//vWxiaItjnU6ti2iNT4pRTTmnqMPsIECiggABaQExDEShWgdyHj/p0af7Zzw/X16dznZcsP8Ro4z+feWZmPP3k4208S/aGzz3x2bNTywJo7tpf/Hr+m/xnT8aKCKRDQABNRx9UQWCDCvTv3z/eXFrf4hreXFYRY/r1a/HxDmy9wP777xenn3py6wcowTNzz4BOPPaoWLC8PgZ0bx7gzaUNMWDgJs0f6AgCBAomIIAWjNJABIpXIPf+wreX1sX89+sj98GMph4rVjfEo698ENeNGtXUYfYVSGCzzYbEgQceWKDRSmeYz39+bNz3pz/E6Z9r/lnQ+17uGiedf0Dp4FgpgRQINP03TQoKVAIBAm0v0KFDhzj9jLPizF/nbr/U9GP0j+tiwoSDo2/fvk0faC+BDSjw9XPPj0unVMSCZU3f6vqHf6yJeVWdYty4cRuwWlMTKD0BAbT0em7FBPIKXHjRf8ayyi1j/2saYk3tun9p517WnHBtXTz3Rk1c84sb8o5hI4G0CHz2s5+NL33lnNjqkpp4s/HG8/ketz5TG+feWxvTHns6Ondu2b1Z841jGwECH1/AS/Af38wZBDIpUFFREY89NSvG7b93bHXZE3HyZ2tjh4EN0aHxFcyX3o24aVZl9B48PJYtmxIdO3bMpEESi6qp/iDee/nRFk1V88HSqOta16JjHbSuwHcuujgGDR4cO37jq3H0LuUxZoua6N014q+LG+LXL3aJF97tFjNn/j4GDRq07sm2ECDQpgK+irNNeQ1OoDgFnnrqqbj7ztvi5T/Pirq6uhi65fCYcOiRMXbs2GjXrvn31BXnqtu+6g8++CAOGH9YLFu+okWTrVmzOm687uexy847tuh4B+UXyN2z9le33BKPN34lZ9XSpbHxoE1i7/3Gr/32o65dGxOpBwECiQsIoImTm5AAAQIECBAgUNoC3gNa2v23egIECBAgQIBA4gICaOLkJiRAgAABAgQIlLaAAFra/bd6AgQIECBAgEDiAgJo4uQmJECAAAECBAiUtoAAWtr9t3oCBAgQIECAQOICAmji5CYkQIAAAQIECJS2gABa2v23egIECBAgQIBA4gICaOLkJiRAgAABAgQIlLaAAFra/bd6AgQIECBAgEDiAgJo4uQmJECAAAECBAiUtoAAWtr9t3oCBAgQIECAQOICAmji5CYkQIAAAQIECJS2gABa2v23egIECBAgQIBA4gICaOLkJiRAgAABAgQIlLaAAFra/bd6AgQIECBAgEDiAgJo4uQmJECAAAECBAiUtoAAWtr9t3oCBAgQIECAQOICAmji5CYkQIAAAQIECJS2gABa2v23egIECBAgQIBA4gICaOLkJiRAgAABAgQIlLaAAFra/bd6AgQIECBAgEDiAgJo4uQmJECAAAECBAiUtoAAWtr9t3oCBAgQIECAQOICAmji5CYkQIAAAQIECJS2gABa2v23egIECBAgQIBA4gICaOLkJiRAgAABAgQIlLaAAFra/bd6AgQIECBAgEDiAgJo4uQmJECAAAECBAiUtoAAWtr9t3oCBAgQIECAQOICAmji5CYkQIAAAQIECJS2gABa2v23egIECBAgQIBA4gICaOLkJiRAgAABAgQIlLaAAFra/bd6AgQIECBAgEDiAgJo4uQmJECAAAECBAiUtoAAWtr9t3oCBAgQIECAQOICAmji5CYkQIAAAQIECJS2gABa2v23egIECBAgQIBA4gICaOLkJiRAgAABAgQIlLaAAFra/bd6AgQIECBAgEDiAgJo4uQmJECAAAECBAiUtoAAWtr9t3oCBAgQIECAQOICFYnPaEICBEpGYM2aNTFnzpyoqqqKwYMHx2abbRbl5f7dWzIXQIEWunLlypg7d26sXr06hgwZEgMGDCjQyIYhQGBDCfibYEPJm5dAhgUWLFgQZ5x2YvTZqHscM35UnH/6hBj1me1j+JabxY033pjhlVtaIQVeeeWVOGzC/rFx/94x8dC94hv/fkBsN2xofHqnbeL3v/99IacyFgECCQuUNTQ+Ep7TdAQIZFhg0aJFsc3WW8RxO9fEuWPqo2+3sn+s9ol5dfG5H66JkyYeE9fd8Kt/bPcDgX8VyD1zvtuuO8aFX4g4dY+y6Nrx79dRfX1D/HZ2fRxy7Zr42VU/ji99+ax/PdV/EyBQBAICaBE0SYkEikVg8eLF0bt37zjhM+3i+uM65C27uqYhuny9Oi684Py4+LuX5T3GxtIWyD3zOWzYsLjumPbx77vnf6fY35bUx5DvrI5bb701vvjFL5Y2mNUTKEIBAbQIm6ZkAmkV+PZ/fCte/eNP4/YT6pssceHyhtjmv8ripVfmeT9fk1KlufOIQ8bF8NVT4qL9m36X2My/Nj4TenOXmP+3d6N9+/aliWXVBIpUoOn/dxfpopRNgMCGEbjztpvj/M/XNjt5v8aX5cdtVxH33Xdfs8c6oLQEPvjgg/jDQ1PjG2P+960b6xPYdbPyGNyjPqZPn76+Q2wnQCClAgJoShujLALFJpD7xPvrby2I7Qa17NfKThtXx+wXni22Zaq3jQXmzZsXgzbqEN0qmw+guVJ2GVQTL774YhtXZXgCBAot0LK/KQo9q/EIEMicQC6AdurQ8pdBOzUeumZNdeYcLOiTCeRutdS5Y7sWD9K5fUPjdbSmxcc7kACBdAgIoOnogyoIFL1Aly5domPHDvFOVcturDH3/Q4xZIthRb9uCyisQO5esfMWrIraupZdR3MWVa69N2hhqzAaAQJtLSCAtrWw8QmUiEBZWVkceOABcePTzb90uqa2IW6fFTFu3EElomOZLRXo06dPbL31lnH/n5v+IFtuvNw/dmbMXRVjx45t6fCOI0AgJQICaEoaoQwCWRD4jwsujh9NK4spL9c1uZxuZ1fHyNFjY7vttmvyODtLU+DSy38UZ91bEa++t/4QmnuGdPC3q+OMM8+Knj17liaUVRMoYgG3YSri5imdQBoFZsyYESNHjoyfH90+Tt7jn+/huLy6IS6Z0iGuf7IhFi1e6ms509jAlNR0669uimOPmxj/72sdYtSn/vk9oblnPsdc1RBDt909Jk/5fympWBkECHwcAQH042g5lgCBFgnMmjUrTj7h6Kha9HbstWV59KqsjflVHeOPL62Kw484Mq686pqorKxs0VgOKl2BSZMmxTlf+3L0rlzd+Gn3uujSoSFeWdQxHn91VXzlrK/FJY1fZJB764cHAQLFJyCAFl/PVEygaASef/75eOaZZ6KqqioGDRoUY8aMif79+xdN/Qrd8AI1NTXx1FNPxezZs6O6ujqGDBkSe+21V/To0WPDF6cCAgRaLSCAtprOiQQIECBAgAABAq0R8CGk1qg5hwABAgQIECBAoNUCAmir6ZxIgAABAgQIECDQGgEBtDVqziFAgAABAgQIEGi1gADaajonEiBAgAABAgQItEZAAG2NmnMIECBAgAABAgRaLSCAtprOiQQIECBAgAABAq0REEBbo+YcAgQIECBAgACBVgsIoK2mcyIBAgQIECBAgEBrBATQ1qg5hwABAgQIECBAoNUCAmir6ZxIgAABAgQIECDQGgEBtDVqziFAgAABAgQIEGi1gADaajonEiBAgAABAgQItEZAAG2NmnMIECBAgAABAgRaLSCAtprOiQQIECBAgAABAq0REEBbo+YcAgQIECBAgACBVgsIoK2mcyIBAgQIECBAgEBrBATQ1qg5hwABAgQIECBAoNUCAmir6ZxIgAABAgQIECDQGgEBtDVqziFAgAABAgQIEGi1gADaajonEiBAgAABAgQItEagojUnOYcAAQJZFPjLX/4S1//y2nji0T/G0qVVsfHAgfH5/SbExIkTo3fv3kW95Pr6+pg6dWrcedtNMefFF6Kurj622HJYTDjs6JgwYUK0b9++qNeneAIEikugrKHxUVwlq5YAAQKFF7j4ogviqit/GKd8tiHGblUfG3UuizeWNMQ9syvj1ieWx+zZL8bw4cMLP3ECI1ZXV8f4A/aOt1/7U5y626rYflBZdKgoixffqY9fPN0p3l3VJebMfS06deqUQDWmIECAQIQA6iogQKDkBW66/udx/jlnxXPfKo8+XcvW8Zj+al2M/u81MW3atBg1atQ6+9O8oba2Nrp06RzbDmiIp8+piPLyddd34QONQfSZTo0hdF706tUrzctRGwECGREQQDPSSMsgQKB1Ao8++mjsueeeUXVFZXTtuG44+3DU3/25Ls68v3u8NHd+dO3a9cPNqf/zm+d+I2b9/pp46IymSz1zUsSyAfvHLbfdHWVl63doehR7CRAg0DIBAbRlTo4iQCCjAoeO3y/27frHOGlE82+Jn3BDxzj8q1fGcccdVxQaq1evjoH9e8cL59bFwJ5Nh8pVaxpi8EURr7z61+jXr19RrE+RBAgUr4BPwRdv71ROgMAnFMi9Bf7R6TPiwH9r16KRDthqZTw85fctOjYNBz3//PMxpG+HZsNnrtZOHcpi9LDOMX369DSUrgYCBDIuIIBmvMGWR4DA+gXq6uqiavmq6Ndt/cd8dM/AHmWx8N23P7op1T8vXLgwBvZo+a/5jbvVxoIFC1K9JsURIJANgZb/ZsrGeq2CAAEC/xAoLy+PHt06xaKV/9jU5A8LljdEn779mzwmTTv79OkTC5fXt7ikhSsrom/fvi0+3oEECBBorYAA2lo55xEgUPQCuQA6YvfPxIMv1bVoLQ/+pXPsOXbfFh2bhoN23HHH+Mu7qxtDaPN326upa4iHX/ogPve5z6WhdDUQIJBxAQE04w22PAIEmhY446xz47tTO8bqmqZD2h8aQ+pj88vi0EMPbXrAFO3N3dfz2MYPTH37gebf43rSrfWx1157xYABA1K0AqUQIJBVAZ+Cz2pnrYsAgRYLnHrSCTHjwTtj5rllUdl+3U+LPzm/Pva4YnXMnDkzdtlllxaPm4YDly9fHjttPzwO2fL9uHx8/uccvnlvbVzxx5pYvHix+4CmoWlqIFACAgJoCTTZEgkQaF7gtJMnxi9vuDm+P6EiPr91eWzUpfGbkBbXx6//3D5ueibi2l/eHIccckjzA6XwiNw3IfXu3Su22bgivj5ydewwuDw6ND4p+uI7DXHDs403oF/SPR6Z8VRsvPHGKaxeSQQIZFFAAM1iV62JAIFWCTz99NNx3c+visemT4uqZctjQP++sfd+4+NLZ5wZm266aavGTMtJNTU1ceedd8bdt90Qc+bMafwu+LoYOnTzOPiI4+P4449v/LakLmkpVR0ECJSAgABaAk22RAIECBAgQIBAmgTyvyEoTRWqhQABAgQIECBAIFMCAmim2mkxBAgQIECAAIH0Cwig6e+RCgkQIECAAAECmRIQQDPVToshQIAAAQIECKRfQABNf49USIAAAQIECBDIlIAAmql2WgwBAgQIECBAIP0CAmj6e6RCAgQIECBAgECmBATQTLXTYggQIECAAAEC6RcQQNPfIxUSIECAAAECBDIlIIBmqp0WQ4AAAQIECBBIv4AAmv4eqZAAAQIECBAgkCkBATRT7bQYAgQIECBAgED6BQTQ9PdIhQQIECBAgACBTAkIoJlqp8UQIECAAAECBNIvIICmv0cqJECAAAECBAhkSkAAzVQ7LYYAAQIECBAgkH4BATT9PVIhAQIECBAgQCBTAgJoptppMQQIECBAgACB9AsIoOnvkQoJECBAgAABApkSEEAz1U6LIUCAAAECBAikX0AATX+PVEiAAAECBAgQyJSAAJqpdloMAQIECBAgQCD9AgJo+nukQgIECBAgQIBApgQE0Ey102IIECBAgAABAukXEEDT3yMVEiBAgAABAgQyJSCAZqqdFkOAAAECBAgQSL+AAJr+HqmQAAECBAgQIJApAQE0U+20GAIECBAgQIBA+gUE0PT3SIUECBAgQIAAgUwJCKCZaqfFECBAgAABAgTSLyCApr9HKiRAgAABAgQIZEpAAM1UOy2GAAECBAgQIJB+AQE0/T1SIQECBAgQIEAgUwICaKbaaTEECBAgQIAAgfQLCKDp75EKCRAgQIAAAQKZEhBAM9VOiyFAgAABAgQIpF9AAE1/j1RIgAABAgQIEMiUgACaqXZaDAECBAgQIEAg/QICaPp7pEICBAgQIECAQKYEBNBMtdNiCBAgQIAAAQLpFxBA098jFRIgQIAAAQIEMiUggGaqnRZDgAABAgQIEEi/gACa/h6pkAABAgQIECCQKQEBNFPttBgCBAgQIECAQPoFBND090iFBAgQIECAAIFMCQigmWqnxRAgQIAAAQIE0i8ggKa/RyokQIAAAQIECGRKQADNVDsthgABAgQIECCQfgEBNP09UiEBAgQIECBAIFMCAmim2mkxBAgQIECAAIH0Cwig6e+RCgkQIECAAAECmRIQQDPVToshQIAAAQIECKRfQABNf49USIAAAQIECBDIlIAAmql2WgwBAgQIECBAIP0CAmj6e6RCAgQIECBAgECmBATQTLXTYggQIECAAAEC6RcQQNPfIxUSIECAAAECBDIlIIBmqp0WQ4AAAQIECBBIv4AAmv4eqZAAAQIECBAgkCkBATRT7bQYAgQIECBAgED6BQTQ9PdIhQQIECBAgACBTAkIoJlqp8UQIECAAAECBNIvIICmv0cqJECAAAECBAhkSkAAzVQ7LYYAAQIECBAgkH4BATT9PVIhAQIECBAgQCBTAgJoptppMQQIECBAgACB9AsIoOnvkQoJECBAgAABApkSEEAz1U6LIUCAAAECBAikX0AATX+PVEiAAAECBAgQyJSAAJqpdloMAQIECBAgQCD9AgJo+nukQgIECBAgQIBApgQE0Ey102IIECBAgAABAukXEEDT3yMVEiBAgAABAgQyJSCAZqqdFkOAAAECBAgQSL+AAJr+HqmQAAECBAgQIJApAQE0U+20GAIECBAgQIBA+gUE0PT3SIUECBAgQIAAgUwJCKCZaqfFECBAgAABAgTSLyCApr9HKiRAgAABAgQIZEpAAM1UOy2GAAECBAgQIJB+AQE0/T1SIQECBAgQIEAgUwICaKbaaTEECBAgQIAAgfQLCKDp75EKCRAgQIAAAQKZEhBAM9VOiyFAgAABAgQIpF9AAE1/j1RIgAABAgQIEMiUgACaqXZaDAECBAgQIEAg/QICaPp7pEICBAgQIECAQKYEBNBMtdNiCBAgQIAAAQLpFxBA098jFRIgQIAAAQIEMiUggGaqnRZDgAABAgQIEEi/gACa/h6pkAABAgQIECCQKQEBNFPttBgCBAgQIECAQPoFBND090iFBAgQIECAAIFMCQigmWqnxRAgQIAAAQIE0i8ggKa/RyokQIAAAQIECGRKQADNVDsthgABAgQIECCQfgEBNP09UiEBAgQIECBAIFMCAmim2mkxBAgQIECAAIH0Cwig6e+RCgkQIECAAAECmRIQQDPVToshQIAAAQIECKRfQABNf49USIAAAQIECBDIlIAAmql2WgwBAgQIECBAIP0CAmj6e6RCAgQIECBAgECmBATQTLXTYggQIECAAAEC6Rf4/xCJ8rLJWiUlAAAAAElFTkSuQmCC" style="display: block; margin: auto;" /> ### Section 2.) Creating polygon-intersection-based direct-contacts network using point-location data</p>
<p><strong>Note that this section was run with eval = FALSE because otherwise the processing time for this vignette is longer than what is allotted by CRAN</strong></p>
<p>Here, we show how to create contact networks detailing the number of direct, physical contacts between tracked individuals. We derive polygons represntative of animals’ physical space from point-locations. We then define “contact” as occuring when polygons intersect (i.e., SpTh == 0). However, we re-define this SpTh to account for RTLS accuracy using the findDistThresh function below.</p>
<p>The data set we use, calves2018, is comprised of point-locations collected using a radio-telemetry-based real-time location system (RTLS) (Smartbow GmbH, Weibern, Austria) to monitor the locations of n = 20 steers in a 30m X 35m feedlot pen located at the Kansas State University Beef Cattle Research Center in Manhattan, KS. Manufacturer-reported RTLS spatial resolution and accuracy was 0.5m and 90%, respectively (i.e., 90% of location fixes are within 0.5m of animals’ true locations). Tracked steers were approximately 1.5 years old, with estimated 1.5-m nose-to-tail lengths and 0.5-m shoulder widths, and radio-frequency-identication (RFID) tracking devices were located on animals’ left ears. Data in this set were collected continuously between 00:00:00 06/01/2018 and 11:59:59 06/03/2018 UTC at a 5-10s temporal resolution (i.e., positional fixes for each individual were obtained every 5-10 seconds). However, to reduce processing time in this vignette, we subset the calves2018 data set to only contain point-locations observed between 00:00:00 and 11:59:59 UTC on 06/01/2018.</p>
<p>The steps for direct-contact-network creation are described below.</p>
<p><strong>A.) Subset calves2018 and ensure all required columns exist in the calves data set (i.e., xy coordinates, unique individual IDs, dateTime).</strong></p>
<p><strong>B.) Clean and filter the data set.</strong></p>
<p><strong>C.) Temporally smooth point-locations, ensuring that animals are observed at identical timepoints (Note: this was an unnecessary step in Section 1 because the water trough’s location was fixed and unchanging over time).</strong></p>
<p><strong>D.) Derive calf head and body polygons from point locations.</strong></p>
<p>Note: This is done using a novel methodology described in brief on the contact::referencePoint2Polygon and contact::referencePoint2Polygon help pages, and in detail in Farthing <em>et al.</em> 2020 (the same manuscript in which we introduce this package to the scientific community).</p>
<p><strong>E.) Calculate inter-animal distances at each time step.</strong></p>
<p><strong>F.) Identify what SpTh value will allow us to capture 99% of contacts, polygon intersections, given the RTLS accuracy.</strong></p>
<p><strong>G.) Identify time points when calf heads were within the re-adjusted SpTh distance from one another or body polygons.</strong></p>
<p><strong>H.) Visualize the contact networks with edgeweights weighted according to number of observed contacts.</strong></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;calves2018&quot;</span>) <span class="co">#load the data set</span></span></code></pre></div>
<p><strong>A.) Subset calves2018 and ensure all required columns exist in the calves data set (i.e., xy coordinates, unique individual IDs, dateTime)</strong></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(calves2018) <span class="co">#see that all necessary columns are there.</span></span></code></pre></div>
<p>We will only look at points from the 1st date represented in the data set (06/01/2018). Therefore, we need to get the unique date values in the data.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>calves2018<span class="sc">$</span>date<span class="ot">&lt;-</span>lubridate<span class="sc">::</span><span class="fu">date</span>(calves2018<span class="sc">$</span>dateTime) <span class="co">#add the date column to the data set</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>calves06012018 <span class="ot">&lt;-</span> <span class="fu">droplevels</span>(<span class="fu">subset</span>(calves2018, date <span class="sc">==</span> <span class="fu">unique</span>(calves2018<span class="sc">$</span>date)[<span class="dv">1</span>])) <span class="co">#pull the observations from 06/01/2018</span></span></code></pre></div>
<p><strong>B.) Clean and filter the data set.</strong></p>
<p>Here we run the various spatiotemporal-data-filtering functions offered by the package (i.e., mps, confine, dup). We run them in this particular order because one filtration process may trigger others to remove points that are not necessariliy erroneous. For example, removing duplicated point-locations could create a situation where it appears that individuals moved at a speed exceeding a specified mps threshold. Thus, in this scenario, subsequently running the mps function may remove points that would not have been flagged for removal prior to removing duplicated points.</p>
<p>First, we ensure that points do not represent impossible/highly unlikely movement speeds.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calves_filter1 <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">mps</span>(calves06012018, <span class="at">id =</span> calves06012018<span class="sc">$</span>calftag, <span class="at">point.x =</span> calves06012018<span class="sc">$</span>x, <span class="at">point.y =</span> calves06012018<span class="sc">$</span>y, <span class="at">dateTime =</span> calves06012018<span class="sc">$</span>dateTime, <span class="at">mpsThreshold =</span> <span class="dv">10</span>, <span class="at">lonlat =</span> <span class="cn">FALSE</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">filterOutput =</span> <span class="cn">TRUE</span>)) <span class="co">#we assume that if calves&#39; point-locations suggest they moved faster than 10m/s, points are erroneous and should be removed. #This did not remove any observations.</span></span></code></pre></div>
<p>Now we want to ensure that all points are within the specific feedlot pen boundaries. As calves could not escape fedlot pens, points outside the pen or adjacent feed bunks are erroneous.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>confinementCoords <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">object =</span> <span class="fu">c</span>(<span class="st">&quot;feed&quot;</span>, <span class="st">&quot;feed&quot;</span>, <span class="st">&quot;feed&quot;</span>, <span class="st">&quot;feed&quot;</span>,<span class="st">&quot;fence&quot;</span>, <span class="st">&quot;fence&quot;</span>, <span class="st">&quot;fence&quot;</span>, <span class="st">&quot;fence&quot;</span>, <span class="st">&quot;fence&quot;</span>), <span class="at">x =</span> <span class="fu">c</span>(<span class="fl">46.0118</span>, <span class="fl">46.6482</span>, <span class="fl">58.3415</span>, <span class="fl">57.6507</span>, <span class="fl">60.5775</span>, <span class="fl">29.3054</span>, <span class="fl">16.7602</span>, <span class="fl">17.0590</span>, <span class="fl">46.0309</span>), <span class="at">y =</span> <span class="fu">c</span>(<span class="fl">197.0570</span>, <span class="fl">197.4131</span>, <span class="fl">175.9618</span>, <span class="fl">175.6284</span>, <span class="fl">170.4628</span>, <span class="fl">153.6002</span>, <span class="fl">176.5861</span>, <span class="fl">181.6315</span>, <span class="fl">197.1261</span>)) <span class="co">#these are the x &amp; y coordinates for the feedlot-pen fenceline and adjacent feedbunk vertices. Note that they are arranged in a clockwise order, as the confine function below requires input vertices to be ordered clockwise or counter-clockwise.</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(confinementCoords<span class="sc">$</span>x,confinementCoords<span class="sc">$</span>y,<span class="fu">lines</span>(<span class="fu">c</span>(confinementCoords<span class="sc">$</span>x, confinementCoords<span class="sc">$</span>x[<span class="dv">1</span>]),<span class="fu">c</span>(confinementCoords<span class="sc">$</span>y, confinementCoords<span class="sc">$</span>y[<span class="dv">1</span>])), <span class="at">pch=</span><span class="dv">16</span>, <span class="at">main =</span> <span class="st">&quot;confinement polygon&quot;</span>) <span class="co">#this is what the pen outline looks like. </span></span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calves_filter2<span class="ot">&lt;-</span>contact<span class="sc">::</span><span class="fu">confine</span>(calves_filter1, <span class="at">point.x =</span> calves_filter1<span class="sc">$</span>x, <span class="at">point.y =</span> calves_filter1<span class="sc">$</span>y, <span class="at">confinementCoord.x =</span> confinementCoords<span class="sc">$</span>x, <span class="at">confinementCoord.y =</span> confinementCoords<span class="sc">$</span>y, <span class="at">filterOutput =</span> <span class="cn">TRUE</span>)) <span class="co">#this removed an additional 1784 observations</span></span></code></pre></div>
<p>Finally, we want to remove duplicate observations. This is an important step because many data-processing functions below require that no duplicates exist.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calves_filter3<span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">dup</span>(calves_filter2, <span class="at">id =</span> calves_filter2<span class="sc">$</span>calftag, <span class="at">point.x =</span> calves_filter2<span class="sc">$</span>x, <span class="at">point.y =</span> calves_filter2<span class="sc">$</span>y, <span class="at">dateTime =</span> calves_filter2<span class="sc">$</span>dateTime, <span class="at">avg =</span> <span class="cn">FALSE</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">filterOutput =</span> <span class="cn">TRUE</span>)) <span class="co">#it looks like there were no duplicates to remove in the first place. We&#39;re ready to proceed with analyses.</span></span></code></pre></div>
<p><strong>C.) Temporally smooth point-locations, ensuring that animals are observed at identical timepoints</strong></p>
<p>Note: This was an unnecessary step in Section 1 because the water trough’s location was fixed and unchanging over time.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">#create our data set that shows calves average position every 10 seconds</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calves<span class="fl">.10</span>secSmoothed <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">tempAggregate</span>(<span class="at">x =</span> calves_filter3, <span class="at">id =</span> calves_filter3<span class="sc">$</span>calftag, <span class="at">point.x =</span> calves_filter3<span class="sc">$</span>x, <span class="at">point.y =</span> calves_filter3<span class="sc">$</span>y, <span class="at">dateTime =</span> calves_filter3<span class="sc">$</span>dateTime, <span class="at">secondAgg =</span> <span class="dv">10</span>, <span class="at">extrapolate.left =</span> <span class="cn">FALSE</span>, <span class="at">resolutionLevel =</span> <span class="st">&quot;reduced&quot;</span>, <span class="at">extrapolate.right =</span> <span class="cn">FALSE</span>, <span class="at">na.rm =</span> <span class="cn">TRUE</span>, <span class="at">smooth.type =</span> <span class="dv">2</span>)) </span></code></pre></div>
<p>Note that we set na.rm to TRUE and resolutionLevel to “reduced” here. This means that temporal intervals between observed relocations may not necessarily be equidistant, as when individuals were not observed at a given time point, they are removed from the data set (rather than introducing an NA instead). This speeds up later processing functions (because the size of calves.10secSmoothed is relatively small). Please note, however, that having equidistant temporal intervals between observed relocations is a requirement for some contact-function processes (e.g., a variation of the path-randomization procedure described by Spiegel <em>et al.</em> 2016 that can be implemented using contact::randomizePaths). Thus, before these specific processes could be run, the data set must be re-processed with na.rm == FALSE.</p>
<p><strong>D.) Derive calf head and body polygons from point locations.</strong></p>
<p>We could transform empirical point-locations into polygon vertices one vertex at a time by repeatedly using the repositionReferencePoint function, but the referencePoint2Polygon function provides an expediant shortcut for generating square/rectangular polygons from point-locations. Moving forward, we assume that calves’ body sizes are equivalent and stable, and that 0.333 m X 0.333 and 1.167 m X 0.5 m polygons accurately represent areas where calves’ heads and bodies exist, respectively.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="do">##Create 0.333 m X 0.333 m calf head polygons.</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Note that this is done using the original reference points, which denote the locations of RFID tags on individuals&#39; left ears.</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calf_heads <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">referencePoint2Polygon</span>(<span class="at">x =</span> calves<span class="fl">.10</span>secSmoothed, <span class="at">id =</span> calves<span class="fl">.10</span>secSmoothed<span class="sc">$</span>id, <span class="at">dateTime =</span> calves<span class="fl">.10</span>secSmoothed<span class="sc">$</span>dateTime, <span class="at">point.x =</span> calves<span class="fl">.10</span>secSmoothed<span class="sc">$</span>x, <span class="at">point.y =</span> calves<span class="fl">.10</span>secSmoothed<span class="sc">$</span>y, <span class="at">direction =</span> <span class="cn">NULL</span>, <span class="at">StartLocation =</span> <span class="st">&quot;DL&quot;</span>, <span class="at">UpDownRepositionLen =</span> <span class="fl">0.333</span>, <span class="at">LeftRightRepositionLen =</span> <span class="fl">0.333</span>, <span class="at">CenterPoint =</span> <span class="cn">FALSE</span>, <span class="at">MidPoints =</span> <span class="cn">FALSE</span>, <span class="at">immobThreshold =</span> <span class="dv">0</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">modelOrientation =</span> <span class="dv">90</span>)) <span class="co">#Note that we do not specify an immobility threshold here. This is because the head polygons will later be unioned with body polygons generated from different point-locations, and prematurely thresholding them will potentially cause misalignment between the two polygons.</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(calf_heads) </span></code></pre></div>
<p>When creating the head polygons, we set direction == NULL because we do not have gyroscopic data detailing movement directions associated with each relocation event. Thus, polygons are subject to the assumptions pertaining to deriving polygons from point-locations as described by Farthing <em>et al.</em> (2020). (<em>see</em> the contact::referencePoint2Polygon help page for a brief description of these assumptions).</p>
<p>Note that the referencePoint2Polygon function assumes the input point-locations represent a single vertex of desired polygons. Because calves’ heads are not the same width as their bodies (i.e., 1.167 m X 0.5 m ; L X W), and are assumed to be centered at the front of the body, however, we must move reference points (on the left ear) to the left by 0.0835 m to reposition them at the upper-left corner of calves bodies before creating body polygons. Additionally, note that we are assuming ears are parallel to shoulder-tips.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(leftShoulder.point<span class="ot">&lt;-</span>contact<span class="sc">::</span><span class="fu">repositionReferencePoint</span>(<span class="at">x =</span> calves<span class="fl">.10</span>secSmoothed, <span class="at">id =</span> calves<span class="fl">.10</span>secSmoothed<span class="sc">$</span>id, <span class="at">dateTime =</span> calves<span class="fl">.10</span>secSmoothed<span class="sc">$</span>dateTime, <span class="at">point.x =</span> calves<span class="fl">.10</span>secSmoothed<span class="sc">$</span>x, <span class="at">point.y =</span> calves<span class="fl">.10</span>secSmoothed<span class="sc">$</span>y, <span class="at">direction =</span> <span class="cn">NULL</span>, <span class="at">repositionAngle =</span> <span class="dv">180</span>, <span class="at">repositionDist =</span> <span class="fl">0.0835</span>, <span class="at">immobThreshold =</span> <span class="dv">0</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">modelOrientation =</span> <span class="dv">90</span>))  <span class="co">#Again, see that we do not specify a immobility threshold here.</span></span></code></pre></div>
<p>Now we have the left-shoulder points, but before we create the bodies, let’s take a moment to examine these new points more closely.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(leftShoulder.point) </span></code></pre></div>
<p>See that moving the points changed the calculated dx,dy values from those associated with empirical data points. Therefore, movement angles calculated from these data points will differ from values calculated using the empirical observations. Because of that, when creating body polygons, we must specify that the function use angle values from the empirical data set. Luckily, the function allows for this very easily.</p>
<p>Additionally, the differing calculated-distance values will potentially cause misalignment errors when unioning the head and body polygons if either is created with a specified immobility threshold (<em>see</em> referencePoint2Polygon help page). As outlined by Farthing <em>et al.</em> (2020), in the absence of accompanying gyroscopic data, movement angles are calculated based on observed relocation events with the assumption that all individuals are forward-facing when moving. Thus, specifying an immobility threshold (i.e., observed relocation distance required for us to state that movement actually occurred) is necessary to reduce directional errors by discounting observed movements so miniscule that the majority of the modeled physical-space is likely unaffected (e.g., head shaking), and therefore would not be repositioned. Thus, prior to unioning the polygons, we will not implement an immobility threshold.</p>
<p>Moving forward, let’s generate the vertices for calves’ anterior- and posterior-body polygons (i.e., we’re dividing body polygons into two halves). Rather than running the referencePoint2Polygon function twice, we instead set MidPoints = TRUE, which will effectively identify vertices for the bottom of anterior body sections/top of posterior ones.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calf_bods <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">referencePoint2Polygon</span>(<span class="at">x =</span> leftShoulder.point, <span class="at">id =</span> leftShoulder.point<span class="sc">$</span>id, <span class="at">dateTime =</span> leftShoulder.point<span class="sc">$</span>dateTime, <span class="at">point.x =</span> leftShoulder.point<span class="sc">$</span>x.adjusted, <span class="at">point.y =</span> leftShoulder.point<span class="sc">$</span>y.adjusted, <span class="at">direction =</span> leftShoulder.point<span class="sc">$</span>movementDirection, <span class="at">StartLocation =</span> <span class="st">&quot;UL&quot;</span>, <span class="at">UpDownRepositionLen =</span> <span class="fl">1.167</span>, <span class="at">LeftRightRepositionLen =</span> <span class="fl">0.5</span>, <span class="at">CenterPoint =</span> <span class="cn">FALSE</span>, <span class="at">MidPoints =</span> <span class="cn">TRUE</span>, <span class="at">immobThreshold =</span> <span class="dv">0</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">modelOrientation =</span> <span class="dv">90</span>)) <span class="co">#note that direction == leftShoulder.point$movementDirection. </span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(calf_bods) <span class="co">#notice the additional columns compared to calf_heads</span></span></code></pre></div>
<p>Now we can take vertices from calf_heads and calf_bods, and create a vertex set {V(it)} delineating the calves full bodies (i.e., we essentially union the calf_heads and calf_bod polygons). Note that in this calf_FullBody data frame, vertex1 is located on calves left shoulders, and vertices are ordered in a clockwise direction from that point.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>calf_FullBody <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">calf_id =</span> calf_bods<span class="sc">$</span>id, <span class="at">vertex1.x =</span> calf_bods<span class="sc">$</span>cornerPoint1.x, <span class="at">vertex1.y =</span> calf_bods<span class="sc">$</span>cornerPoint1.y, <span class="at">vertex2.x =</span> calf_heads<span class="sc">$</span>cornerPoint1.x, <span class="at">vertex2.y =</span> calf_heads<span class="sc">$</span>cornerPoint1.y, <span class="at">vertex3.x =</span> calf_heads<span class="sc">$</span>cornerPoint2.x, <span class="at">vertex3.y =</span> calf_heads<span class="sc">$</span>cornerPoint2.y, <span class="at">vertex4.x =</span> calf_heads<span class="sc">$</span>cornerPoint3.x, <span class="at">vertex4.y =</span> calf_heads<span class="sc">$</span>cornerPoint3.y, <span class="at">vertex5.x =</span> calf_heads<span class="sc">$</span>cornerPoint4.x, <span class="at">vertex5.y =</span> calf_heads<span class="sc">$</span>cornerPoint4.y, <span class="at">vertex6.x =</span> calf_bods<span class="sc">$</span>cornerPoint2.x, <span class="at">vertex6.y =</span> calf_bods<span class="sc">$</span>cornerPoint2.y,  <span class="at">vertex7.x =</span> calf_bods<span class="sc">$</span>midPoint2.x, <span class="at">vertex7.y =</span> calf_bods<span class="sc">$</span>midPoint2.y, <span class="at">vertex8.x =</span> calf_bods<span class="sc">$</span>cornerPoint3.x, <span class="at">vertex8.y =</span> calf_bods<span class="sc">$</span>cornerPoint3.y, <span class="at">vertex9.x =</span> calf_bods<span class="sc">$</span>cornerPoint4.x, <span class="at">vertex9.y =</span> calf_bods<span class="sc">$</span>cornerPoint4.y, <span class="at">vertex10.x =</span> calf_bods<span class="sc">$</span>midPoint4.x, <span class="at">vertex10.y =</span> calf_bods<span class="sc">$</span>midPoint4.y, <span class="at">dateTime =</span> calf_bods<span class="sc">$</span>dateTime)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>                            </span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(calf_FullBody)</span></code></pre></div>
<p>This is an example of what a calf full-body polygon looks like.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>fullBodyExample <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">section =</span> <span class="fu">c</span>(<span class="st">&quot;body&quot;</span>, <span class="fu">rep</span>(<span class="st">&quot;head&quot;</span>, <span class="dv">4</span>), <span class="fu">rep</span>(<span class="st">&quot;body&quot;</span>, <span class="dv">5</span>)), <span class="at">x =</span> <span class="fu">unname</span>(<span class="fu">unlist</span>(calf_FullBody[<span class="dv">10</span>,<span class="fu">c</span>(<span class="fu">seq</span>(<span class="dv">2</span>,<span class="dv">21</span>, <span class="at">by =</span><span class="dv">2</span>))])), <span class="at">y =</span> <span class="fu">unname</span>(<span class="fu">unlist</span>(calf_FullBody[<span class="dv">10</span>,<span class="fu">c</span>(<span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">21</span>, <span class="at">by =</span><span class="dv">2</span>))])))</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>{<span class="fu">plot</span>(fullBodyExample<span class="sc">$</span>x,fullBodyExample<span class="sc">$</span>y, <span class="at">col =</span> <span class="fu">as.factor</span>(fullBodyExample<span class="sc">$</span>section), <span class="fu">lines</span>(<span class="fu">c</span>(fullBodyExample<span class="sc">$</span>x, fullBodyExample<span class="sc">$</span>x[<span class="dv">1</span>]),<span class="fu">c</span>(fullBodyExample<span class="sc">$</span>y, fullBodyExample<span class="sc">$</span>y[<span class="dv">1</span>])), <span class="at">pch=</span><span class="dv">16</span>, <span class="at">main =</span> <span class="st">&quot;Calves&#39; body shape&quot;</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a> <span class="fu">legend</span>(<span class="fl">39.2</span>, <span class="fl">193.8</span>, <span class="at">col =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>), <span class="at">legend =</span> <span class="fu">c</span>(<span class="st">&quot;body&quot;</span>, <span class="st">&quot;head&quot;</span>), <span class="at">cex =</span> <span class="fl">0.7</span>, <span class="at">pch =</span> <span class="dv">16</span>)}</span></code></pre></div>
<p>Recall that these polygons were created without specifying immobility threshold values.</p>
<p>For reference, we show an example of a misalignment that may occur when enforcing an immobility threshold of 0.1m for head and body polygons prior to unioning them. Note that this is the same polygon that was shown above (i.e., same individual at the same time step).</p>
<p>So, even when polygons are ultimately derived from the same empirical data, it’s clear that repositioning the reference point-locations to create different polygons does not allow for the implementation of immobility thresholds prior to unioning procedures.</p>
<p>We are still interested in reducing directional errors by implementing this threshold, however. We can do that now with a simple for-loop.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>immobility.vec<span class="ot">&lt;-</span> (<span class="fu">which</span>(leftShoulder.point<span class="sc">$</span>dist.original <span class="sc">&lt;</span> <span class="fl">0.1</span>) <span class="sc">+</span> <span class="dv">1</span>) <span class="co">#create a vector describing which polygons in calf_heads2 moved &lt; 0.1m. Note that we add 1 to returned values because leftShoulder.point$dist.original details the distance to the successive point, but we want distance to the proceeding point.</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>calf_FullBody.immob<span class="ot">&lt;-</span>calf_FullBody</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>calf_bods.matrix<span class="ot">&lt;-</span><span class="fu">as.matrix</span>(calf_FullBody[,<span class="dv">2</span><span class="sc">:</span><span class="dv">21</span>]) <span class="co">#convert vertex columns to matrix for speed</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(l <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(immobility.vec)){ </span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  calf_bods.matrix[immobility.vec[l],] <span class="ot">&lt;-</span> calf_bods.matrix[(immobility.vec[l]<span class="sc">-</span><span class="dv">1</span>),] <span class="co">#replace l-th observations in calf_FullBody with the preceding coordinates.</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>calf_FullBody.immob[,<span class="dv">2</span><span class="sc">:</span><span class="dv">21</span>]<span class="ot">&lt;-</span> calf_bods.matrix <span class="co">#replace with the updated locations.</span></span></code></pre></div>
<p>Now that we have defined the (x,y) coordinates for the full-body vertex set {V(it)}, we can use these polygons to generate contact networks. Before we move on, however, we will briefly mention another aspect of polygon-derivation that may also introduce movement-orientation error into the data set. As we note on the referencePoint2Polygon help page, in the absence of accompanying gyroscopic-movement data, under normal circumstances we would consider removing observations from our vertex set that represent movements outside of a pre-determined dt (i.e., length of time between consecutive relocation events) threshold. This would be done to ensure that relocation intervals are sufficiently small to minimize chances that animals face unknown directions between observed relocations. For the purposes of this vignette, however, we will assume that the dt-introduced errors are irrelevant.</p>
<p><strong>E.) Calculate inter-animal distances at each time step.</strong></p>
<p>The first step to network creation is calculating the distance between calves at each time step.</p>
<p>Note: the dist2All_df does not allow NA values in polygon coordinates (recall that the polygon derivation process introduced some NAs). Before running this function, we must remove these NA coordinates.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>naObs<span class="ot">&lt;-</span><span class="fu">which</span>(<span class="fu">is.na</span>(calf_FullBody.immob<span class="sc">$</span>vertex10.x) <span class="sc">==</span> T) <span class="co">#by identifying where NAs were introduced for any body vertex (other than vertex 1, which was left-shoulder point used to generate other vertices), we can determine what rows to remove. Note: we use a body vertex because two NAs were introduced (i.e., one from left-shoulder repositioning and another from polygon creation), as opposed to only one.</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>FullBody_noNAs<span class="ot">&lt;-</span><span class="fu">droplevels</span>(calf_FullBody.immob[<span class="sc">-</span>naObs,]) <span class="co">#remove NA coordinates</span></span></code></pre></div>
<p>Now we can proceed with calculating inter-animal distances.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(fullbody_distances<span class="ot">&lt;-</span>contact<span class="sc">::</span><span class="fu">dist2All_df</span>(<span class="at">x =</span> FullBody_noNAs, <span class="at">id =</span> FullBody_noNAs<span class="sc">$</span>calf_id, <span class="at">dateTime =</span> FullBody_noNAs<span class="sc">$</span>dateTime, <span class="at">point.x =</span> <span class="cn">NULL</span>, <span class="at">point.y =</span> <span class="cn">NULL</span>, <span class="at">poly.xy =</span> FullBody_noNAs[,<span class="dv">2</span><span class="sc">:</span><span class="dv">21</span>], <span class="at">elev =</span> <span class="cn">NULL</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">dataType =</span> <span class="st">&quot;Polygon&quot;</span>, <span class="at">lonlat =</span> <span class="cn">FALSE</span>, <span class="at">numVertices =</span> <span class="dv">10</span>)) <span class="co">#these are the distances from the nearest polygon edges (i.e., not distance from centroids).</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(fullbody_distances) <span class="co">#note that if individuals were not observed in the data at a specific time, the function reports NAs for their respective distances.</span></span></code></pre></div>
<p><strong>F.) Identify what SpTh value will allow us to capture 99-percent of contacts, polygon intersections, given the RTLS accuracy.</strong></p>
<p>We initially define “contact” as occurring when two polygons intersect (i.e., SpTh = 0) on any given time step. As we did in Section 1, however, we want to account for RTLS positional accuracy by sampling from a multivariate distribution. Thus, here we seek to determine what SpTh value will likely capture 99-percent of contacts, defined as polygon intersections, and re-define “contact” accordingly.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>polySpThValues<span class="ot">&lt;-</span>contact<span class="sc">::</span><span class="fu">findDistThresh</span>(<span class="at">n =</span> <span class="dv">100000</span>, <span class="at">acc.Dist1 =</span> <span class="fl">0.5</span>, <span class="at">acc.Dist2 =</span> <span class="cn">NULL</span>, <span class="at">pWithin1 =</span> <span class="dv">90</span>, <span class="at">pWithin2 =</span> <span class="cn">NULL</span>, <span class="at">spTh =</span> <span class="dv">0</span>) <span class="co">#spTh represents the initially-defined spatial threshold for contact. #spTh represents the initially-defined spatial threshold for contact. Note that we&#39;ve chosen to use 100,000 in-contact point-location pairs here.</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>polySpThValues <span class="co">#it looks like an adjusted SpTh value of approximately 1.38 m will likely capture 99% of contacts, defined as instances when point-locations were within 0 m of one another, given the RTLS accuracy. #Note that because these confidence intervals are obtained from distributions generated from random samples, every time this function is run, results will be slightly different. </span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>polyCI_99<span class="ot">&lt;-</span><span class="fu">unname</span>(polySpThValues[[<span class="st">&quot;spTh.adjustments&quot;</span>]][<span class="dv">3</span>]) <span class="co">#we will use this SpTh value moving forward.</span></span></code></pre></div>
<p><strong>G.) Identify time points when calf heads were within the re-adjusted SpTh distance from one another or body polygons.</strong></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calf_fullBody_contacts <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">contactDur.all</span>(fullbody_distances,<span class="at">dist.threshold=</span>polyCI_99,<span class="at">sec.threshold=</span><span class="dv">10</span>, <span class="at">blocking =</span> <span class="cn">FALSE</span>, <span class="at">equidistant.time =</span> <span class="cn">FALSE</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">reportParameters =</span> <span class="cn">TRUE</span>)) <span class="co">#Note that because we are not interested in making a time-aggregated network with &gt; 1 temporal levels, we set blocking = FALSE to reduce processing time.</span></span></code></pre></div>
<p><strong>H.) Visualize the contact networks with edgeweights weighted according to number of observed contacts.</strong></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co">#Generate a static network edge set (aggregated to the day resolution) </span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(fullBody_edges<span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">ntwrkEdges</span>(<span class="at">x =</span> calf_fullBody_contacts, <span class="at">importBlocks =</span> <span class="cn">FALSE</span>, <span class="at">removeDuplicates =</span> <span class="cn">TRUE</span>))</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co">#visualize the network</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>fullBody.network <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">simplify</span>(igraph<span class="sc">::</span><span class="fu">graph_from_data_frame</span>(<span class="at">d=</span>fullBody_edges, <span class="at">directed=</span>F),<span class="at">remove.multiple =</span> T, <span class="at">remove.loops =</span> T) <span class="co">#create network</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">V</span>(fullBody.network)<span class="sc">$</span>color<span class="ot">&lt;-</span> <span class="st">&quot;orange1&quot;</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">V</span>(fullBody.network)<span class="sc">$</span>size <span class="ot">&lt;-</span><span class="dv">13</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">E</span>(fullBody.network)<span class="sc">$</span>width <span class="ot">&lt;-</span> fullBody_edges<span class="sc">$</span>duration<span class="sc">/</span><span class="dv">50</span> <span class="co">#edge width is proportional to contact frequency</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">E</span>(fullBody.network)<span class="sc">$</span>color <span class="ot">&lt;-</span> <span class="st">&quot;black&quot;</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>igraph<span class="sc">::</span><span class="fu">plot.igraph</span>(fullBody.network, <span class="at">vertex.label.cex=</span><span class="fl">0.4</span>, <span class="at">layout =</span> igraph<span class="sc">::</span>layout.circle) </span></code></pre></div>
</div>
<div id="section-3.-test-networks-against-null-models" class="section level3">
<h3>Section 3.) Test networks against NULL models</h3>
<p><strong>Note that this section was run with eval = FALSE because otherwise the processing time for this vignette is longer than what is allotted by CRAN</strong></p>
<p>Farine (2017) provides a general overview of the importance of NULL-model creation and evaluation. Briefly, comparing empirical contact networks to NULL models, allows us to determine if observed contacts occur more or less frequently than would be expected at random. This allows us to test a number of hypotheses. For example, by comparing contact-networks derived from tracked sleepy lizard (<em>Tiliqua rugosa</em>) point-locations, Spiegel <em>et al.</em> (2016) determined that this species exhibits sociality. The point-location randomization procedure they developed for NULL-model creation accounts for environmental drivers of movement, suggesting that any observed differences in contact frequency (relative to NULL models) are driven by social behaviors. This point-location randomization procedure can be implemented through the randomizePaths function.</p>
<p>Here, using previously-loaded/created data, we demonstrate how to create NULL contact-network models and how to statistically test network models against one another using <em>contact</em> functions. Specifically, we determine if the total hourly number of full-body contacts occur more or less frequently than would be expected at random in the calves06012018 data set. Furthermore, we use a Mantel test (Mantel 1967) to assess if head X head and full-body contact networks are related to one another.</p>
<p>The steps for NULL-model creation and evaluation are described below.</p>
<p><strong>A.) Generate the empirical hourly head X head and full-body contact networks.</strong></p>
<p><strong>B.) Temporally smooth previously-filtered calves2018 point-locations, ensuring that animals are observed at identical timepoints AND that all timepoints are equidistant</strong> (Recall that equidistant timepoints are a requirement for using contact::randomizePaths to randomize point-locations according to the Spiegel <em>et al</em> (2016) method variant we will use below).</p>
<p><strong>C.) Randomize the newly-created point-location data set.</strong></p>
<p><strong>D.) Generate contact networks from randomized data (NULL models).</strong></p>
<p><strong>E.) Test empirical networks against NULL models.</strong></p>
<p><strong>F.) Test empirical networks against each other.</strong></p>
<p>Recall the data sets created in Section 2 that we will continue using.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(calves06012018) <span class="co">#point-location data set to be temporally smoothed</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(FullBody_noNAs) <span class="co">#polygon data set</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(fullbody_distances) <span class="co">#distances between each full-body polygon at each timestep</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>polyCI_99 <span class="co">#adjusted polygon-contact SpTh value that likely captures 99% of of inter-calf contacts, defined as instances when calf polygons intersect, given the RTLS accuracy.</span></span></code></pre></div>
<p><strong>A.) Generate the hourly head X head and full-body contact networks.</strong></p>
<p>Here we create a time-aggregated contact network describing head X head contacts and full-body contacts (i.e., body polygons unioned with head polygons) between calves each hour of 06/01/2018.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calf_fullBody_contacts.hr <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">contactDur.all</span>(fullbody_distances,<span class="at">dist.threshold=</span>polyCI_99,<span class="at">sec.threshold=</span><span class="dv">10</span>, <span class="at">blocking =</span> <span class="cn">TRUE</span>, <span class="at">blockUnit =</span> <span class="st">&quot;hours&quot;</span>, <span class="at">blockLength =</span> <span class="dv">1</span>, <span class="at">equidistant.time =</span> <span class="cn">FALSE</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">reportParameters =</span> <span class="cn">TRUE</span>)) <span class="co">#Note that the difference between this edge set and the one created in Section 2 is that blocking is set to TRUE here. </span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>headVertexColumns<span class="ot">&lt;-</span><span class="dv">4</span><span class="sc">:</span><span class="dv">11</span> <span class="co">#these are the columns within FullBody_noNAs representative of head polygons</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(head_distances<span class="ot">&lt;-</span>contact<span class="sc">::</span><span class="fu">dist2All_df</span>(<span class="at">x =</span> FullBody_noNAs, <span class="at">id =</span> FullBody_noNAs<span class="sc">$</span>calf_id, <span class="at">dateTime =</span> FullBody_noNAs<span class="sc">$</span>dateTime, <span class="at">point.x =</span> <span class="cn">NULL</span>, <span class="at">point.y =</span> <span class="cn">NULL</span>, <span class="at">poly.xy =</span> FullBody_noNAs[,headVertexColumns], <span class="at">elev =</span> <span class="cn">NULL</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">dataType =</span> <span class="st">&quot;Polygon&quot;</span>, <span class="at">lonlat =</span> <span class="cn">FALSE</span>, <span class="at">numVertices =</span> <span class="dv">4</span>)) <span class="co">#Note that the difference between this distance set and the one created in Section 2 is that poly.xy and numVertices arguments refer to head polygons only </span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calf_head_contacts.hr <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">contactDur.all</span>(head_distances,<span class="at">dist.threshold=</span>polyCI_99,<span class="at">sec.threshold=</span><span class="dv">10</span>, <span class="at">blocking =</span> <span class="cn">TRUE</span>, <span class="at">blockUnit =</span> <span class="st">&quot;hours&quot;</span>, <span class="at">blockLength =</span> <span class="dv">1</span>, <span class="at">equidistant.time =</span> <span class="cn">FALSE</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">reportParameters =</span> <span class="cn">TRUE</span>)) </span></code></pre></div>
<p>Now that we have our empirical edge set to be analyzed, we need to create our NULL model.</p>
<p><strong>B.) Randomize the newly-created point-location data set.</strong></p>
<p>In accordance with the Spiegel <em>et al.</em> (2016) procedure, individuals’ movement paths (i.e., sequential relocation events) within defined time blocks (1 hour-length blocks here) will be shuffled around in time, so that individuals visit the same places, just not at the same times. For a more detailed description of the relationship between blockUnits and shuffleUnits in the randomizePaths function, please see the randomizePaths function help page. In the interest of relatively quick processing speeds later on, we will only create 2 randomized replicates here.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>nRandomizations <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="co">#we will create 2 randomized-hour replicates.</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calf_fullBody.random.list <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">randomizePaths</span>(<span class="at">x =</span> FullBody_noNAs, <span class="at">id =</span> FullBody_noNAs<span class="sc">$</span>calf_id, <span class="at">dateTime =</span> FullBody_noNAs<span class="sc">$</span>dateTime, <span class="at">point.x =</span> <span class="cn">NULL</span>, <span class="at">point.y =</span> <span class="cn">NULL</span>, <span class="at">poly.xy =</span> FullBody_noNAs[,<span class="dv">2</span><span class="sc">:</span><span class="dv">21</span>], <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">dataType =</span> <span class="st">&quot;Polygon&quot;</span>, <span class="at">numVertices =</span> <span class="dv">10</span>, <span class="at">blocking =</span> <span class="cn">TRUE</span>, <span class="at">blockUnit =</span> <span class="st">&quot;hours&quot;</span>, <span class="at">blockLength =</span> <span class="dv">1</span>, <span class="at">shuffle.type =</span> <span class="dv">1</span>, <span class="at">indivPaths =</span> <span class="cn">TRUE</span>, <span class="at">numRandomizations =</span> nRandomizations)) <span class="co">#see that we can directly randomize the polygon set. There&#39;s no need to take it back to the point data (unless you really want to). See also that we randomize the polygon set with NAs already removed so that we don&#39;t have to do it again.</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">data.frame</span>(calf_fullBody.random.list[[<span class="dv">1</span>]])) <span class="co">#here&#39;s what the output looks like when you set shuffle.type == 1. See that there are separate coordinate columns designated &quot;rand.&quot;</span></span></code></pre></div>
<p><strong>C.) Generate contact networks from randomized data (NULL model).</strong></p>
<p>Now we need to put the randomized data through the same network-creation procedures we used for the empirical data. Note that many of the function arguments below now use take column names as inputs, as opposed to vectors of length nrow(x), which we used above. This allows us input list objects as “x” in these functions, with variable values called by other arguments.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>fullBodyVertexColnames<span class="ot">&lt;-</span> <span class="fu">colnames</span>(<span class="fu">data.frame</span>(calf_fullBody.random.list[[<span class="dv">1</span>]]))[<span class="dv">27</span><span class="sc">:</span><span class="dv">46</span>] <span class="co">#these are the column names of columns in the data frames contained within calf_fullBody.random.list that contain randomized full-body-polygon-vertex information.</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(fullBody_distances.random<span class="ot">&lt;-</span>contact<span class="sc">::</span><span class="fu">dist2All_df</span>(<span class="at">x =</span> calf_fullBody.random.list, <span class="at">id =</span> <span class="st">&quot;id&quot;</span>, <span class="at">dateTime =</span> <span class="st">&quot;dateTime&quot;</span>, <span class="at">point.x =</span> <span class="cn">NULL</span>, <span class="at">point.y =</span> <span class="cn">NULL</span>, <span class="at">poly.xy =</span> fullBodyVertexColnames, <span class="at">elev =</span> <span class="cn">NULL</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">dataType =</span> <span class="st">&quot;Polygon&quot;</span>, <span class="at">lonlat =</span> <span class="cn">FALSE</span>, <span class="at">numVertices =</span> <span class="dv">10</span>)) <span class="co">#Note that the difference between this distance set and the one created in Section 2 is that x is a list and other arguments are given column-name information rather than vectors of length(nrow(x)).</span></span></code></pre></div>
<p>Having calculated inter-polygon distances at each time step, we can now create the contact networks from randomized data sets (i.e., NULL models). Note that we continue to use polyCI_99 as the SpTh value. Note that, though the randomized data sets were generated using point-locations where relocations were separated by equidistant timepoints, because we removed polygons with NAs so that the dist2All_df function would work, we can no longer gaurantee that the equidistant-timepoint assumption is valid. Thus, when running the contactDur.all function below, we set the equidistant.time argument to FALSE.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(calf_fullBody_contacts.hr.random <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">contactDur.all</span>(<span class="at">x =</span> fullBody_distances.random, <span class="at">dist.threshold =</span> polyCI_99, <span class="at">sec.threshold=</span><span class="dv">10</span>, <span class="at">blocking =</span> <span class="cn">TRUE</span>, <span class="at">blockLength =</span> <span class="dv">1</span>, <span class="at">blockUnit =</span> <span class="st">&quot;hours&quot;</span>, <span class="at">equidistant.time =</span> <span class="cn">FALSE</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>, <span class="at">reportParameters =</span> <span class="cn">TRUE</span>)) </span></code></pre></div>
<p><strong>E.) Test empirical networks against NULL model.</strong></p>
<p>Through the <em>contactCompare_chisq</em> function we will use Chi-squared tests to evaluate if differences exist between observed fullbody contacts and expected contacts described in the NULL model. Essentially, we will perform a “goodness-of-fit” test to determine if empirical data fit the distribution describe in the NULL model. Therefore our NULL hypothesis/hypotheses is that the distribution of empirical contacts is equivalent to that NULL-model contacts, and our alternative hypothesis is that a difference exists.</p>
<p>The function takes four data inputs that we must generate before any analyses can be done: x.summary, y.summary, x.potential, and y.potential. The <em>.summary</em> inputs represent summarized edge weights in the empirical and randomized edge sets, respectively. While, the <em>.potential</em> inputs show the maximum number of potential timeBlocks each individual could have been present for over the course of the data-collection period. emp.input and rand.input represent the empirical and NULL netowork edgesets, respectively.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co">#create x.potential</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(x.potential <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">potentialDurations</span>(fullbody_distances, <span class="at">blocking =</span> <span class="cn">TRUE</span>, <span class="at">blockLength =</span> <span class="dv">1</span>, <span class="at">blockUnit =</span> <span class="st">&quot;hours&quot;</span>, <span class="at">distFunction =</span> <span class="st">&quot;dist2All_df&quot;</span>)) <span class="co"># see blocking information here</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(x.potential) <span class="co">#see the layout of x.potential</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="co">#create y.potential</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(y.potential <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">potentialDurations</span>(fullBody_distances.random, <span class="at">blocking =</span> <span class="cn">TRUE</span>, <span class="at">blockLength =</span> <span class="dv">1</span>, <span class="at">blockUnit =</span> <span class="st">&quot;hours&quot;</span>, <span class="at">distFunction =</span> <span class="st">&quot;dist2All_df&quot;</span>))</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="co">#summarize empirical contacts </span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(x.summary <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">summarizeContacts</span>(<span class="at">x =</span> calf_fullBody_contacts.hr, <span class="at">importBlocks =</span> <span class="cn">TRUE</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>)) <span class="co">#note that </span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(x.summary) <span class="co">#see the layout of x.summary</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="co">#summarize randomized contacts </span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(y.summary <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">summarizeContacts</span>(<span class="at">x =</span> calf_fullBody_contacts.hr.random[[<span class="dv">2</span>]], <span class="at">importBlocks =</span> <span class="cn">TRUE</span>, <span class="at">avg =</span> <span class="cn">TRUE</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>))</span></code></pre></div>
<p>A few things to note in the summary processing immediately above: 1.) When creating the x.summary object, we could have set importBlocks = FALSE to return edge weights summed over all time blocks. However, in this example we’re interested in comparing total hourly contact rates to the NULL model, so here, in both the x.potential and x.sumary objects we ensure that block information is present. 2.) See that we averaged the edge weights of NULL-model list objects together by setting avg = TRUE in the summarizeContacts function.</p>
<p>Now we can proceed with the comparison.</p>
<p>Note that because of the warning settings in the chisq.test function, we cannot effectively silence the error “Chi-squared approximation may be incorrect.” As such, you may get many warnings to that end.</p>
<p>These warnings are normal and occur when expected pairwise counts are are very small, leading to potentially innacurate chi-squared values. Warnings for specific pairwise tests can be seen in the “warnings” column of the data frames within function output. If you receive these warnings, consider using contactCompare_binom instead contactCompare_chisq.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(fullBody_NULLTest1<span class="ot">&lt;-</span>contact<span class="sc">::</span><span class="fu">contactCompare_chisq</span>(x.summary, y.summary, x.potential, y.potential, <span class="at">importBlocks =</span> <span class="cn">TRUE</span>, <span class="at">shuffle.type =</span> <span class="dv">1</span>, <span class="at">popLevelOutput =</span> <span class="cn">TRUE</span>, <span class="at">parallel =</span> <span class="cn">FALSE</span>)) <span class="co">#Note that we MUST indicate the shuffle.type used to randomize point-locations.</span></span></code></pre></div>
<p>See that when the “popLevelOutput” argument is TRUE the function returns a list containing two data frames. The first data frame contains Chi-squared test results for individual-level observed node degree, total contact durations, and observed contacts between specific inidividuals. The second data frame contains population-level variations of these metrics. In the case of our example, what we’re after is precisely the popLevelOutput frame. See below that we now have a comparison to the NULL model at each time block.</p>
<p>Note that most of the “metrics” represented here are numbers. These are actually unique calf IDs, and each row indicates contact durations with that specific individual.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(fullBody_NULLTest1[[<span class="dv">2</span>]])</span></code></pre></div>
<p><strong>E.) Test empirical networks against each other.</strong></p>
<p>Note that the <em>contactCompare_chisq</em> function SHOULD NOT be used to compare two empirical networks, as the function assumes x.summary and y.summary represent observed and expected values, respectively. If users want to compare two empirical networks, we can compare network similarity using Mantel’s permutation test (Mantel 1967) through the <em>contactCompare_mantel</em> function.</p>
<p>Below we test the similarity of the fullbody and head X head contact networks. See that like <em>contactCompare_chisq</em>, this function requires x.summary and y.summary inputs (though the y.summary DOES NOT have to represent a NULL model). Recall that we have already made the x.summary object, which relates to the fullbody contact network. Before we can run the Mantel test, we must summarize the head X head contact network.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(y.summary2 <span class="ot">&lt;-</span> contact<span class="sc">::</span><span class="fu">summarizeContacts</span>(calf_fullBody_contacts.hr, <span class="at">importBlocks =</span> <span class="cn">FALSE</span>)) <span class="co">#create the new y.summary</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="fu">system.time</span>(mantelOutput<span class="ot">&lt;-</span>contact<span class="sc">::</span><span class="fu">contactCompare_mantel</span>(x.summary, <span class="at">y.summary =</span> y.summary2, <span class="at">numPermutations =</span> <span class="dv">1000</span>, <span class="at">alternative.hyp =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="at">importBlocks =</span> <span class="cn">FALSE</span>))</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>mantelOutput <span class="co">#based on the reported p-value, given an alpha-level of 0.05, we can reject the NULL hypothesis that these two networks are unrelated. (This is as we would expect, because the head X head-contact network is nested within the fullBody-contact network. If they were not similar, we would have a problem.)</span></span></code></pre></div>
<p><strong>References</strong></p>
<p>Farine, D.R., 2017. A guide to null models for animal social network analysis. <em>Methods in Ecology and Evolution</em> 8:1309-1320. <a href="https://doi.org/10.1111/2041-210X.12772" class="uri">https://doi.org/10.1111/2041-210X.12772</a>.</p>
<p>Farthing, T.S., Dawson, D.E., Sanderson, M.W., and Lanzas, C. 2020. Accounting for space and uncertainty in real-time location system-derived contact networks. <em>Ecology and Evolution</em> 00:1-14. <a href="https://doi.org/10.1002/ece3.6225" class="uri">https://doi.org/10.1002/ece3.6225</a>.</p>
<p>Mantel, N. 1967. The detection of disease clustering and a generalized regression approach. <em>Cancer Research</em> 27:209–220.</p>
<p>Spiegel, O., Leu, S.T., Sih, A., and C.M. Bull. 2016. Socially interacting or indifferent neighbors? Randomization of movement paths to tease apart social preference and spatial constraints. <em>Methods in Ecology and Evolution</em> 7:971-979. <a href="https://doi.org/10.1111/2041-210X.12553" class="uri">https://doi.org/10.1111/2041-210X.12553</a>.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
